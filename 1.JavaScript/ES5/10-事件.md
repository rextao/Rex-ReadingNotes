# 事件
## 1、概述
1. js和HTML交互是通过事件实现的
1. 可以使用监听器（或处理程序）来预订事件，以便事件发生时执行某段代码
1. IE8+和其他所有浏览器都实现了DOM2级事件核心部分
1. IE8是最后一个仍用专有事件系统的主要浏览器
1. DOM3级出现，增强的DOM事件API更加繁琐，使事件有时难，有时容易，核心概念要知道

## 2、事件流
1. 概述
    - 事件流描述的是从页面中接收事件的顺序
1. 事件冒泡
    - 事件由最具体的元素接收，然后逐级向上传播
    - 所有现代浏览器都支持事件冒泡，但具体实现还有一定的差异
1. 事件捕获
    - 从不太具体的节点更早接收事件，然后最具体的节点最后接收事件
    - DOM2规范要求从document对象开始传播，但浏览器都是从window对象开始传播
1. DOM事件流
    - DOM2级事件，规定具体事件包含三个阶段：事件捕获阶段，处理目标阶段和事件冒泡阶段

## 3、事件处理程序
1. 概述
    - 响应某个事件的函数叫事件处理程序（或事件监听）
1. HTML事件处理程序
    - 把事件写在HTML代码中，直接写或调用一个函数
    - 独到之处
        - 会创建一个封装着元素属性值的函数，内部可以直接使用event对象，不用定义也不用从函数参数列表中读取
        - 函数内部，this值等于事件的目标元素
    - 缺点
        - 如定一个一个函数在HTML最底部，页面一加载就点击按钮，会没有反应
        - 事件处理程序的作用域链在不同浏览器可能会导致不同结果
        - HTML与js紧耦合
1. DOM0级事件处理程序
    - 将一个函数赋值给一个事件处理程序属性
    - 每一个元素都有自己的事件处理程序属性，如onclick
    - 使用DOM0级方法指定的事件处理程序被认为是元素的方法，因为这时候事件处理程序的作用域是在元素作用域中运行的，this为当前元素
    - btn.onclick = null 删除事件处理程序
1. DOM2级事件处理程序
    - 定义了两个方法
        - addEventListener()
            - 只能有removeEventListener()删除
            - 意味着匿名函数添加的事件处理程序将无法删除
        - removeEventListener()
        - 所有节点都支持这两个方法
            - 参数：要处理的事件名，参数为click，无on
            - 参数：事件处理程序的函数
            - 参数：true，捕获阶段，flase，冒泡阶段
    - 使用DOM2级添加事件函数的好处是能添加多个事件处理程序
    - 大多数情况下，都是讲事件处理程序添加到事件流的冒泡阶段，可以最大限度兼容浏览器
1. IE事件处理程序
    - IE8和IE8以前
    - 方法
        - attachEvent()
        - detachEvent()
            - 参数：事件处理程序名称， 参数为onclick
            - 参数：事件处理程序函数
        - IE8之前只支持事件冒泡
    - DOM0级事件处理程序会在所属元素的作用域内运行，attachEvent是在全局作用域中运行，因此this为window
    - 在编写跨浏览器代码时，这一点很关键
    - 事件处理程序触发不是按照添加顺序执行的（DOM级是），是相反顺序执行的
1. 跨浏览器的事件处理程序
    - 要保证处理事件的代码性能在大多数浏览器下一致运行，只需关注冒泡阶段

## 4、事件对象
1. 概述
    - 在触发DOM上的事件时，会产生一个事件对象event，这个对象包含着所有事件相关的信息
    - 所有浏览器都支持event对象，但支持方式不同
1. DOM中的事件对象
    - 兼容DOM的浏览器（无论是DOM0还是DOM2），都会传入event对象
    - event对象会因为触发的事件类型不同，可用的属性和方法也不一样
    - event.currentTarget：事件处理程序当前正在处理事件的那个元素，始终等于事件处理程序内部的this
    - event.target：事件目标，如在body上绑定click，点击的button，实际这个值是button的引用，它是click事件真正的目标
    - event.type：需要一个函数处理多个事件，利用switch
    - preventDefault()
        - 阻止特定事件的默认行为，如a链接的
        - 只有cancelable（是否可以取消默认行为）属性设置为true的，才可以用此方法取消
    - stopPropogation()方法
        - 立即停止事件在DOM层的传播
        - 可同时取消事件捕获和冒泡
    - eventPhase属性
        - 确定事件当前正位于事件流的什么阶段
    - 只有事件处理程序执行期间，event对象存在，一旦事件处理程序结束，event被销毁
1. IE中的事件对象
    - 使用DOM0级，event对象作为window对象的一个属性
    - 使用attachEvent添加，event对象作为参数传入事件处理函数
    - 因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标，最好使用event.srcElement
    - returnValue属性，取消给定事件的默认行为
1. 跨浏览器的事件对象
    - IE中event对象的全部信息和方法DOM对象中都有，只是实现方式不同

## 5、事件类型
### 概述
1. IE9在内的主流浏览器都支持DOM2级事件和DOM3级事件
1. 有些浏览器会为DOM和BOM实现其他专有事件

### UI事件
1. 概述
    - 指不一定与用户操作有关的事件
    - 多数这些事件都与window对象有关
    - 属于DOM2级事件
1. load事件
    - 页面完全加载完会触发window上的load事件
    - 一般说，在window发生的任何事件都可以body元素中通过相应特性来指定
    - 根据DOM2级规范，应该在document实现这个事件，为确保向后兼容，都是在window上实现的
    - 图像上也可以触发事件
    - event对象并没有什么有用信息
    - 如果在页面加载完操作document.body可能会导致错误
    - IE9+，script元素也会被触发load事件，方便判断js文件是否加载完
1. unload事件
    - 文档被完全卸载后触发
    - 用户从一个页面切换到另一个页面，会触发unload事件
    - unload事件发生，那么页面加载后存在的哪些对象，此时不一定存在，操作DOM节点或元素的样式可能会出错
1. resize事件
    - 事件在window上触发
    - 何时触发，不同浏览器机制不同，Firefox是用户停止调整窗口大小时触发，其他是改变1px就触发
    - 不要加入大量代码，因为会频繁执行，会使浏览器反应变慢
1. scroll事件
    - 在window对象上发生，实际表示的是页面中相应元素的变化
    - 也会在文档滚动期间重复调用
1. 焦点事件
    - focus和blur不冒泡
    - 当焦点从a元素移动到b元素，触发事件顺序是
            a——focusout
            b——focusin
            a——blur
            a——DOMFocusOut
            b——focus
            b——DOMFocusIn
1. 鼠标事件
    - DOM3级，定义了9个鼠标事件
    - 页面所有元素都支持，mouseenter和mouseleave不冒泡，其他会
    - 取消鼠标事件默认行为还会影响其他事件
    - 只有同一个元素上相继发生mousedown和mouseup，才会触发click，其中一个被取消，click事件就不会发生
    - 双击一个元素，事件发生顺序
        - mousedown
        - mouseup
        - click
        - mousedown
        - mouseup
        - click
        - dbclick
1. 滚轮事件（mousewheel事件）
    - 客户区坐标位置
        - 鼠标事件都是在浏览器视口中的特定位置上发生的
        - 位置信息保存在event对象的clientX和clientY属性中
        - 这些值不包括页面滚动距离，位置并不表示鼠标在页面上的位置
    - 页面坐标位置
        - pageX和pageY属性
            - 页面什么位置发生
            - 从页面而不是视口左上角计算位置
    - 屏幕坐标位置
        - screenX和screenY属性
            - 鼠标相对于整个屏幕的坐标信息
    - 修改键
        - 点击鼠标，键盘的某些键的状态也可以影响到所要采取的行动
        - DOM规定
            - shiftKey
            - ctrlKey
            - altKey
            - metaKey:windows下表示windows键，苹果下表示Cmd键
            - 按下为true，否则为false
        - if(event.shiftKey){...} 点击鼠标且按下shift键会执行
        - IE8之前不支持metaKey键
    - 相关元素
        - 发生mouseover和mouseout事件时，还会涉及更多元素
        - 对于mouseout，事件主目标是失去光标的元素，相关元素是获得光标的元素
        - relatedTarget属性
            - 只有上面两个事件有值，其他事件为null
            - IE8之前不支持
    - 鼠标按钮
        - 对于mouseup和mousedown事件
        - event对象的button属性
            - 0：鼠标主按钮
            - 1：鼠标中间按钮
            - 2：鼠标次按钮
            - IE8之前与上面DOM规范值不同，需要转换
    - 更多事件信息
        - detail属性
            - 对于鼠标事件，表示在同一位置点击多少次
            - 从1开始计数
        - mouseup和mousedown相继发生算一次点击，如中间移动位置则重新计数
    - 鼠标滚轮事件
        - mousewheel事件
        - event.wheelDelta属性
            - 向前滚动：120倍数
            - 向后滚动：-120倍数
        - 事件可以在任意元素上触发，最终冒泡到document或window对象
        - 注意：不同浏览器兼容有问题
            - Opera 9.5之前，正负号相反
            - Firefox名为DOMMouseScroll事件，值为+-3
1. 键盘与文本事件
    - 概述
        - 键盘事件支持主要遵循DOM0级，DOM3事件也制定了规范
        - keydown（按下任意键触发），keypress（按下字符键），keyup，虽然所有元素都支持，但只有在输入框才最有用
        - 用户按着一个字符键不放，会重复触发keydown和keypress
        - 用户按着非字符键不放，重复触发keydown
    - 键码
        - keydown和keyup事件
            - event.keyCode属性
            - 对于字母字符键，对应ASCII编码
            - 非字符键，有编码表
        - 有特殊情况，如分号，不同浏览器keyCode值可能不同
    - 字符编码
        - keypress事件
            - 会影响到屏幕的文本显示
    - DOM3级变化
        - event.key：按下键的字符串，键对应的键名，如shift，ctrl
        - event.char
            - 按下字符键，行为与key相同
            - 非字符键，为null
        - event.location属性
            - 按下什么位置的键，值为0,1,2,3,4,5，表示数字小键盘，手柄等
            - chrome和safari支持keyLocation的等价属性，有bug，始终为0
        - getModifierState()：检测修改键是否被按下
        - 因为存在浏览器差异和浏览器支持问题，慎用
    - textInput事件
        - DOM3级新事件
        - 用户在可编辑区输入字符时，会触发这个事件
        - 与keypress区别
            - keypress：任何元素都可以触发，这个只能是可编辑区触发
            - keypress：能够影响文本显示的键会触发（如退格键），这个是输入实际字符时候触发
        - event.data属性
            - 用户输入的字符，非ASCII编码，如q就是q，大写q就是Q
        - event.inputMethod属性
            - 文本输入到文本框的方式
            - IE支持这个属性
1. 复合事件
    - DOM3级新添加的事件
    - 用于处理输入法编辑器（IME）的输入序列，可以让用户输入在物理键盘上找不到的字符

## 6、变动事件
1. 概述
    - DOM2级，能在DOM的某一部分发生变化时给出提示，为XML和XHTML设计，但不限于这两种
    - DOM3级，作废了一些DOM2级的变动事件
1. 删除节点
    - 使用removeChild()或replaceChild()从DOM中删除节点
    - 触发DOMNodeRemoved事件
        - event.target：被删除的节点（目标节点）
        - event.relatedNode：目标节点父节点的引用
    - DOMNodeRemovedFromDocument事件
        - 如果被移除节点有子节点，所有子节点和被移除节点都会发生这个事件
        - 不会冒泡
    - DOMSubtreeModefied事件
        - 这个事件的目标是被移除节点的父节点
1. 插入节点
    - 使用appendChild()或replaceChilde()或insertBefore()向DOM中插入节点
    - DOMNodeInsert事件
        - event.target：插入节点（目标节点）
        - event.relatedNode：目标节点父节点的引用
    - DOMNodeInsertedIntoDocument事件
        - 不冒泡
    - DOMSubtreeModefied事件
        - 触发新插入节点的父节点

### HTML事件
1. 概述
    - 详尽列出浏览器应该支持的所有事件
    - 介绍一些浏览器完善支持的，并非所有事件
1. contextmenu事件
    - 事件出现的目的是：屏蔽右键关联的默认上下文菜单
    - 事件是冒泡的，可以在document指定事件处理程序，用以处理页面发生的所有此类事件
    - 使用这个事件
        - 首先应先屏蔽事件的默认行为，保证浏览器不显示默认的上下文菜单
        - 创建一个div，当事件发生时，获取鼠标点击位置，将位置给div设置上
1. beforeunload事件
    - 当浏览器窗口关闭或者刷新时，会触发beforeunload事件 

    - 如果处理函数为Event对象的`returnValue`属性赋值非空字符串，浏览器会弹出一个对话框，来询问用户是否确定要离开当前页面（如下示例）。

    - 有些浏览器会将返回的字符串展示在弹框里，但有些其他浏览器只展示它们自定义的信息 

    - 有些浏览器，如firefox，webkit，在window或document添加这个事件，浏览器就不会缓存当前页面 

    - ```javascript
    	window.addEventListener("beforeunload", function (event) {
    	  event.returnValue = "haha"; 
    	});
    	```

    - 补：2-HTML\2-HTML5\Document.visibilityState （页面卸载）
1. DOMContentLoad事件
    - 形成完整DOM树后触发，不理会js，css，图像是否下载完
    - 与onload不同，支持页面早期添加事件处理程序，意味着可尽早让用户和页面交互
    - 事件冒泡到window，但目标实际是document
    - 在不支持这个事件的浏览器，可以设置一个0毫秒的超时调用，js处理完后立即调用，但无法保证所有环境中超时调用都早于load事件触发
1. readystatechange事件
    - 目的：提供与文档或元素加载状态有关的信息
    - IE为文档的某些部分提供，
    - 支持事件的有个readyState属性：包含5个值，表示状态（未初始化，正在加载，加载完毕，交互）
    - 问题：
        - 并非所有对象都经历这个几个状态
        - event事件不提供任何信息，没有目标对象
        - 与load事件一起用，无法预测两者的先后顺序
        - 交互阶段不一定早于完成阶段
            - 解决办法：同时检测两个阶段
            - 检测到了要移除事件处理程序，避免其他阶段再执行
    - document.readyState == "interactive" 与DOMContentLoaded事件触发时间大致相同
    - 注意
        - 最重要的是一并检测readyState的两个状态
        - 注意事件涉及的问题
1. pageshow和pagehide事件
    - Firefox和Opera特性，往返缓存（back-forward cache或bfcache）
    - 使用户在使用浏览器后退和前进，加快页面转换速度，缓存保存了DOM结构和js状态
    - 如页面在bfcache中，再打开页面不会触发load事件
    - Firefox提供的新事件，但除IE9之前，其他支持
        - pageshow
            - 页面显示时触发，load事件之后
            - 事件目标为document，但事件处理程序必须添加到window上
            - persisted属性
                - true：页面保存在bfcache中
        - pagehide
            - 页面卸载时触发，unload事件之前
    - 注意
        - 指定了onunload事件处理程序的页面会自动排除在bfcache中，即使事件处理程序为空
        - 原因，unload事件一般是撤销load事件中执行的操作，跳过load事件，可能导致页面不正常
1. haschange事件
    - HTML5新增
    - URL列表发生变化时，通知开发人员
    - 必须添加到window对象上
    - 事件处理程序中，最好实用location.hash确定当前的参数列表

## 7、内存与性能
### 概述
1. js添加到页面事件数量直接影响页面整体运行性能
1. 原因
    - 每个函数都是对象，都占内存
    - 导致DOM访问次数增多

### 事件委托
1. 解决事件处理程序过多的解决方案，利用事件冒泡
1. 如click，会冒泡到document层，无需为每个按钮设置click，可以在document同一处理
1. 可以利用target.id，确认是点击的哪个按钮
1. 优点
    - document对象很快就可以访问，单击元素呈现在页面上，就立即具备适当功能
    - 事件处理程序添加少，DOM引用就少，花时间更少
1. 限制js与DOM元素连接的数量

### 移除事件处理程序
1. 当事件处理程序给元素时，运行的浏览器代码和js之间存在一个连接，这样连接越多，页面执行起来越慢
1. 空事件处理程序造成性能问题
    - 原因一
        - 文档中删除滴带有事件处理的元素
        - 如使用removeChild()，replaceChild(),innerHTML等方法
        - 如带事件处理程序的元素被innerHTML删除，事件处理程序可能无法被gc回收
        - 可以在替换直接将事件处理函数置null，btn.onclick = null
    - 原因二
        - 页面卸载时候，IE8之前会有问题，其他浏览器或多或少有
        - 页面卸载之前，未清理干净的事件处理程序会在内存中

## 8、模拟事件
### 概述
1. 测试web应用时候，很有用
1. DOM2级为此规定了模拟特定事件的方式

### DOM中的事件模拟
1. document.createEvent()方法
    - 创建event对象
    - 参数
        - DOM2级英文复数:DOM2级无键盘事件
        - DOM3级英文单数
1. dispatchEvent():触发事件
1. 模拟鼠标事件
    - 创建事件对象
        - event = document.createEvent("MouseEvents")
    - 初始化事件对象
        - btn = event.initMouseEvent();
        - 有15个参数，参数与鼠标事件的event对象包含属性一一对应
    - 触发事件
        - btn.dispatchEvent(event);
1. 模拟键盘事件
    - 模拟键盘事件
        - 创建事件对象
             - event = document.createEvent("KeyBoardEvent")
    - 初始化事件对象
        - btn = event.initKeyEvent();
1. 模拟其他事件
    - 浏览器很少使用变动事件和HTML事件，因为使用受到限制
1. 自定义DOM事件
    - 创建事件对象
        - event = document.createEvent("CustomEvent")
    - 初始化事件对象
        - btn = event.initCustomEvent();

### IE中的事件模拟
1. IE8之前，思路一致，但实现不一样
1. 创建事件对象
    - event = document.createEventObject()
    - 不接收参数
1. 初始化事件对象
    - event.screenX = 100;
    - event.screenY = 0;
1. 触发事件
    - btn.fireEvent("onclick",event);
    - 调用fireEvent会自动添加scrElement和type属性
1. 模拟IE事件，采用相同模式