

# 背景

1. 想将整个老铁视频模块作为视频播放器，在内容中台，璇玑内部其他业务引用
2. 独立发包 + 接口引用后端独立部署服务，如果使用ap代理，可能会导致日后代理混乱，使用独立后端服务，主要是后端需要解决跨域问题
3. 注意：vue-cli提供的打包工具，可以直接生成npm包，比自己处理方便的多



# 问题处理

## axios如何处理

1. axios通常处理是挂载在window对象上，或挂载在vue上，这样不太好；

2. 可以使用一个文件，导出实例，避免通用的挂载在Vue.$http上

   ```javascript
   import axiosLib from 'axios';
   const axiosInstance = axiosLib.create({
       timeout: 30 * 1000,
   });
   export const http = axiosInstance;
   ```

   

## 打包后的dist文件，无法调试？

1. 主要问题是，组件库，利用alias，对源码路径引用做了修改，与璇玑或测试项目的有冲突
2. 最好组件库不要使用alias

## component-api引入问题

1. 从璇玑项目迁移老铁，使用component-api，一般不会使用此开发组件

2. 导致如下问题：demo页ok，但引入璇玑后，onmounted 函数不请求接口？

   - 排除是`composition-api`未正确被`Vue.use`

3. 如`@vue/composition-api'`不使用外部引用，如下先后顺序不影响

   ```javascript
   import App from './App.vue';// 我的组件，会在main.ts中调用vue.use(composition)
   import VueCompositionAPI from '@vue/composition-api';
   Vue.use(VueCompositionAPI);
   ```

   - vue一般是外部引用的，组件的`composition-api` 与 璇玑`composition-api`并不是一份；
   - 而`Vue.use(composition-api)`只能注册一次，故会导致，璇玑注册的`composition-api`，但组件内的`composition-api`并未被注册

4. 改用外部引用后会报：`onMounted is called when there is no active component instance to be`

   ```javascript
   // 由于采用如下项目结构
   - ks-polaris-hot-video
   	- node_modules
   		- composition-api
   	- src /// 组件代码
   - src // 璇玑主程序代码
   - node_modules
   ```

   - 虽然组件使用外部引用，但对于`index.vue`的`import {xxxx} from 'composition-api'`还是会引用到`ks-polaris-hot-video/node_modules`下

5. 将组件代码，拷贝到璇玑demo页面 无问题；发现的此问题



## 字体文件问题

1. 通过npm run inspect ，可以检查cli3 的webpack配置，可以看fonts字体的limit，如果字体比较小不会单独打包为文件

2. 注意iconfont的class是否正确，开始iconfont配置的前缀错误，导致一直没有font样式

3. 直接引入css即可，可以把兼容ie6等的删除

   ```css
   @font-face {font-family: "iconfont";
     src: url('data:application/x-font-woff2;xxxxxx')
   }
   .iconfont {
     xxxxx
   }
   ```

   

## 外部引入组件，只希望引入js，而无需引入css

1. 方式一：把css打包到js里面

   ```javascript
   css: {
     extract: false,
   }
   ```

2. 方式二： 将css单独打包

   - `vue inspect`默认是加载development配置，需要` --mode  build`  保证获取的是build环境下的配置

   - 改变`extract-css `配置

     ```javascript
     chainWebpack: config => {
       config.plugin('extract-css').tap(options => {
         options[0].filename = 'index.umd.min.css';
         return options;
       });
     },
     ```

   - 注意：默认情况，css-extract，会输出为`css/xxxxx.css`文件，最好filename也命名为`css/xxxxx`，否则要调整module的publicPath，较为麻烦



## `babel-plugin-component` 不生效

1. 打包产物包含全部element内容？？很奇怪

1. `vue inspect`检查，cli的配置，发现ts配置了babel-loader，是否配置未生效？？

1. 随便引入一个特性`@babel/plugin-proposal-optional-chaining`，看是否可以用新语法写代码？？是ok的没问题；

1. 在babel插件打断点，判断代码是否进入插件逻辑

  ```javascript
  plugins: [
    [
      './node_modules/babel-plugin-component',
      {
        libraryName: '@ks/kwai-ui-next',
        styleLibraryName: 'theme-new-era',
      },
    ],
  ],
  ```

  - 如下方式配置，并使用webstorm断点方式，debugger是无效的；

  - 而且有时并不生效，可能需要更改下`babel.config.js`内容，保存后，再尝试debugger

  - 发现，ts文件中的`@ks/next-xxxx`并没有进入，如下的插件代码

    ```javascript
    if (value === libraryName) {
      node.specifiers.forEach(function (spec) {
        if (types.isImportSpecifier(spec)) {
          specified[spec.local.name] = spec.imported.name;
          moduleArr[spec.imported.name] = value;
        } else {
          libraryObjs[spec.local.name] = value;
        }
      });
    }
    ```

  - 但未发现cli存在+ts的问题（github与Stack Overflow）都无发现；
  
1. 重新建简单vue-cli3 + ts + element 项目，发现按需引入是可以的，对比各种配置。。。

   - 发现：ts配置`compilerOptions.module === commonJs` 会导致不生效，可以使用esnext

1. **但突然发现。。。。不对呀；打包的产物不应该包含node_modules呀**！！！！！！！！！

   - 使用vue cli 提供的打包命令`cross-env NODE_ENV=production vue-cli-service build --target lib --name index`
   - cross-env` 解决跨平台的ENV配置；`NODE_ENV=prodution` 最好带上，很多包可能会依赖这个进行压缩

1. 特别注意：如果将element打包到dist中，外部依赖环境如果升级版本，会导致错误（璇玑icon没有了）



## Vue-cli build与自己build 表现不一致

1. 特别注意：

   - 如果代码中用到的包未配置外部依赖，则会默认打包到结果中

   - 手动指定需要externals的库即可，无需使用`webpack-node-externals`

     ```javascript
     config.externals = [
       'vue',
       'dayjs',
       'axios',
       '@vue/composition-api',
       '@ks/ks-admin-video-player/dist/main',
       '@ks/kwai-ui-next',
       /^lodash\/.+$/,
     ];
     ```

2. 直接执行cli封装的命令`cross-env NODE_ENV=production vue-cli-service build --target lib --name index --formats umd`

   - 但本地测试，页面会报 element 的组件未注册，根据上述描述，页面使用了element ，却未打包到结果中，

   - 经过分析，也发现main.ts 内容未被执行，自己写build命名，会将element打包到结果中

     ```javascript
     module.exports = {
         chainWebpack: config => {
             config.plugin('extract-css').tap(options => {
                 options[0].filename = 'css/index.css';
                 return options;
             });
             return config;
         },
         configureWebpack: config => {
             config.output.filename = 'index.umd.js';
             config.output.libraryTarget = 'umd';
             config.optimization.splitChunks = false;
         },
     };
     
     ```

   - 通过源码console，发现此命令的默认入口文件为：`src/App.vue`

   - 非常僵硬，目前使用版本源码，options 配置的entry 并未对配置merge；

   - 注意看文档命令介绍。。。。。`vue-cli-service build [options] [entry|pattern]`，是可以传入入口文件的

3. 至此，两种方式打包产物保持一致





## 其他问题

1. 安装最新版本less与less-loader，报错
   - TypeError: this.getOptions is not a function [closed]
   - 参考：https://stackoverflow.com/questions/66082397/typeerror-this-getoptions-is-not-a-function，降低less与less-loader版本。。

2. 登录问题

   - 内容中台登录成功，但璇玑不一定登录成功

   - 接口无璇玑cookie，需要window.open，访问璇玑登录sso种上cookie

   - 解决办法是：进入页面后，先请求一个接口，如果返回未登录（sso）拦截，返回信息会有跳转的sso地址；然后生成链接，让用户跳转；跳转后，转入老铁页面即可

3. 如何build后自动publish

   - 利用lerna，可以做简单的管理，但是只用lerna管理publish，感觉有点多余
   - 参见vuex，自己实现一个简单的publish管理
   - 实际` npm version patch` 会自动更新package.json 的版本
   - 但问题是：程序执行publish时，需要登录（user等），故。。就再手动执行`npm publish`

4. build多个版本（不同参数有不同配置）

   - build版本可能为了在璇玑中测试，可能需要将dist文件直接输出到璇玑demo页面下
   - 自己yy，`process.env.npm_lifecycle_event`这个参数可以读使用的npm命令`build:business`
   - 然后根据不同执行命令，加载不同的config配置；、
   - 注意：其实无法使用NODE_ENV，做区分，配置其他值，可能导致build程序默认采用development，或其他问题（出现编译出错。。。。。）
   - 这是偷懒的方式，参见vue-cli-service，应该配置一个 --aaaa 参数，对参数进行解析，判断，加载不同配置，可参见：`cli-service/lib/commands/build/index.js`

5. 如何进行压缩

   - `compression-webpack-plugin` 会打包gzip文件
   - 但linux要开启支持，才能使用gzip文件

6. 如何在璇玑中测试？

   - 直接将dist文件输出到测试目录下，方便测试

   - 由于璇玑测试环境与线上环境需要请求的api host不同，故通过如下配置进行了处理

     ```javascript
     // api-config.js
     function getWindowApi() {
         const windowApi = window.KS_POLARIS_HOT_VIDEO_API_HOST || {};
         const host = window.location.host;
         const result = Object.assign({
             default: 'https://mars-platform.corp.xxxxxxx.com',
             'corp.xxxxxxx.com': 'https://mars-platform.corp.xxxxxxxx.com',
             'test.xxxxxxx.com': '',
             localhost: '',
         }, windowApi);
         const findKey = Object.keys(result).find(item => host.includes(item)) || 'default';
         return result[findKey];
     }
     
     export default getWindowApi;
     // axios
     axiosInstance.interceptors.request.use(config => {
         const { url } = config;
         const baseUrl = getWindowApi();
         config.url = `${baseUrl}${url}`;
         return config;
     });
     ```

     - 可以通过window挂载的变量，可以配置请求host，方便测试

7. 如何保证父级安装某个包

   - 可以把外部依赖的包放在peerDependencies里面
   - 但如果给定的版本过高，比如3.0.0，但外部依赖环境，发现3.0.0有bug，想降版本有点僵
   - peerDependencies，里面的依赖，会默认在宿主环境安装，并安装在宿主环境的node_modules下，否则会安装在 我自己包下的node_modules

8. @ks/kwai的样式并未生效， main.ts文件是：

   ```javascript
   import { InfiniteScroll, Loading } from '@ks/kwai-ui-next';
   Vue.use(InfiniteScroll);
   Vue.use(Loading);
   ```

   - 默认并不会把对应的样式进行引入 ，注意引入样式
   - 注意：通过babel-plugin-component ，由于会改写 引入语法，故要修改externals，才能保证不被打包到组件库中

9. 精简publish内容

   - package 配置files字段

10. 样式问题

  - 最好不要使用main,section等，非常容易被外部覆盖

11. 如何缩小core-js文件大小

    1. 不把此文件打包到产物中，直接引用dist的产物会有问题

12. 使用`throttle`函数，会导致滚动后，又往后滚了一段

    - 有options配置，可以配置

13. 水平滚动问题

    - mac触摸板可以实现水平滚动（无需监听scroll）
    - 但滚轮需要监听scroll，通过scrollBy，水平滑动
    - 因此，scroll要禁掉触摸板水平滑动，目前用的hack方式，``${el.deltaY}`.indexOf('.') === -1`，鼠标滚轮会有小数。。
    - scrollBy，步子大点，如1500，滚动会快

14. 垂直无滚动的bug

    - 关键的关键是。内部list高度要高于外部容器，`scroll:auto`才会有滚动
    - 读取10条数据，可能这10条数据累计高度，比外部容器底（外部容器自适应剩余可用高度）

    

    











