# 类
## 类理论
1. 面向对象编程强调的是数据和操作数据的行为本质上是互相关联的
	- 字符是数据，但对字符的处理（长度计算、搜索等）被设计为String类
    - 所有字符串都是 String 类的一个实例
1. 类是一种设计模式
    - js提供了近似类的语法
    - 与其他语言类是不一样的

## 混入（js）
1. js中只有对象，并不存在可以被实例化的“类"
1. js开发者想出一个方法模拟类的类的复制行为，这个方法称之为混入
1. 显式混入
    - 需要手动对子父类进行复制，许多库中被称为extend()

## 小结
1. 实例化（ 或者继承） 一个类意味着“ 把类的行为复制到对象中”，对于每一个新实例来说都会重复这个过程
1. js中没有类似的复制机制，不能创建一个类的多个实例，只能创建多个对象，并建立联系

# 原型
## 原生原型
1. 原生构造函数有自己的 .prototype 对象，如 Array.prototype、 String.prototype 等，这些对象包含其对应子类型所特有的行为特征
2. 将原型作为默认值
    - Function.prototype 是一个空函数
    - RegExp.prototype 是一个“空”的正则表达式（无任何匹配）
    - Array.prototype 是一个空数组
```javascript
function foo(vals, fn, rx) {
    vals = vals || Array.prototype;
    fn = fn || Function.prototype;
    rx = rx || RegExp.prototype;
}
```
		- 利用Array.prototype而非[]进行默认赋值的优缺点（ES6提供了新的默认值方式）
        - 优点
             - .prototypes 已被创建并且仅创建一次，每次调用函数不会多次创建，减少内存和cpu消耗
        - 缺点
            - 如默认值改变，Array.prototype不能随意改变
3. 不要扩展原生方法
	- 在扩展原生方法时需要加入判断条件
		- 这样并不一定百分百安全，比如push，开始自定义可能只是用于push一个参数，但是标准则可以push多个，会造成错误
    - shim/polyfill
        - 能有效地为不符合最新规范的老版本浏览器填补缺失的功能
        - 但是无法填补新的语法
        - 利用ES6-Shim或ES5-Shim可以填充新API，需要利用Traceur等工具才能实现新旧语法转换

## [[Prototype]]
### 概述
1. 几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值
    - 可以为空，但很少见
1. 当进行属性查找时，都会查找[[Prototype]]链

### Object.prototype
1. 所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype
1. 普通对象，指的是不是特定扩展的（如自己弄个空对象，自己扩展）

### 属性设置与屏蔽
1. obj.foo = "bar"的过程
    - obj有foo，[[Prototype]]无foo：设置obj中foo值
    - obj无foo，[[Prototype]]无foo
        为obj创建一个foo属性，并设值
    - obj无foo，[[Prototype]]有foo
        - [[Prototype]]的foo未标记为只读(writable:false)；
            - obj创建foo，并屏蔽上层链所以foo属性
        - [[Prototype]]的foo标记为只读(writable:true)；
            - obj不创建foo，不屏蔽上层链所以foo属性
            - 严格模式下：报错
            - 非严格模式：忽略赋值
        - [[Prototype]]的foo是一个setter
            - obj不创建foo，也不会重新定义这个setter
        - 使用Object.defineProperty(..)可以屏蔽上层属性
        - 因此，此种情况赋值，并不一定会屏蔽prototype链上的值
    - obj有foo，[[Prototype]]有foo：设置obj中foo值
1. 注意如下情况
```javascript
    var cl = console.log;
    var original = {
        a:2
    };
    var obj = Object.create( original );
    cl(original.a); // 2
    cl(obj.a); // 2
    cl(original.hasOwnProperty( "a" )); // true
    cl(obj.hasOwnProperty( "a" )); // false,a属性不是obj的直接属性
    obj.a++; // 隐式屏蔽！
    cl(original.a); // 2
    cl(obj.a); // 3
    cl(obj.hasOwnProperty( "a" )); // true
```
	- ++操作符相当于，obj.a = obj.a + 1;故右边obj.a会先查找prototype链，然后+1后，赋给obj新建的属性a值，屏蔽了original.a

## “类”
1. “类”函数
	- 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性， 它会指向另一个对象（Foo.prototype是一个对象）
```javascript
	function Foo() {}
    var b = new Foo();
    console.log(Object.getPrototypeOf(b) === Foo.prototype);// true
    console.log(Foo.hasOwnProperty("prototype")); //true
```
        - 创建函数Foo，会默认添加一个prototype的属性
        - 当调用new时，会将Foo.prototype关联到a的[[prototype]]链上
        - Object.getProtoypeof()：获取一个对象的原型
        - new Foo() 只是间接完成： 一个关联到其他对象的新对象。
1. 构造函数
```javascript
    function Foo() {}
    var b = new Foo();
    console.log(Foo.prototype.constructor === Foo);// true
    console.log(b.constructor === Foo); //true
```
    - Foo.prototype 默认有一个公有并且不可枚举的属性 .constructor，这个属性引用的是对象关联的函数
    - Foo只是一个普通函数，但用new调用会构建一个对象，赋值给b，这个调用是构造函数调用
    - 在js 中对于“ 构造函数” 最准确的解释是， 所有带 new 的函数调用。
1. 技术
    - 如下代码，主要为了模拟类的行为
```javascript
    function Foo(name) {
        this.name = name;
    }
    Foo.prototype.myName = function () {
        return this.name;
    };
    var a = new Foo('hello');
    var b = new Foo('world');
    console.log(a.myName()); // hello
    console.log(b.myName()); // world
```
       - new Foo会创建一个对象，分别赋给a，b，根据this默认指向，会为a，b创建一个name属性
       - 在创建的过程中， a 和 b 的内部 [[Prototype]] 都会关联到 Foo.prototype 上
       - 当 a和 b 中无法找到 myName 时， 它会（ 通过委托） 在 Foo.prototype 上找到。
    - 不要使用.constructor作为Foo的引用,因为Foo.prototype.constructor并不总指向Foo
```javascript
    function Foo() {}
    Foo.prototype.constructor = "haha";
    var a = new Foo();
    console.log(a.constructor === "haha");// true
    console.log(a.constructor === Foo); //false
    Foo.prototype = {};
    var b = new Foo();
    console.log(b.constructor === Foo);// false
    console.log(b.constructor === Object); //true
```
        - b并没有 .constructor 属性，会委托 [[Prototype]] 链上的 Foo.prototype        Foo.prototype也没有这个属性，会委托给委托链顶端的 Object.prototype，这个对象有.constructor属性，故指向Object（）函数
    - 上述方式重写Foo.prototype.constructor是不对的，这个属性要是不可枚举的，需要使用Object.defineProperty来定义

## 原型继承
1. 概述
	- OO语言一般支持两种继承：接口继承和实现继承
	- js函数没有签名，故支持实现继承，依靠原型链来实现的
	- 继承实现的本质就是重写原型对象
1. 基本情况
```javascript
function Foo(name) {
    this.name = name;
}
Foo.prototype.myName = function() {
    console.log(this.name);
};
function Bar(name,label) {
    Foo.call( this, name );
    this.label = label;
}
Bar.prototype.myLabel = function() {
    console.log(this.label);
};
var a = new Bar( "a", "obj a" );
a.myName(); // 报错，Uncaught TypeError: a.myName is not a function
a.myLabel(); //
```
	- a是Bar实例，当调用a.myName()时，会在Bar和Bar.prototype寻找此函数，找不到报错；Bar函数中的Foo.call只是调用了Foo函数，并不是将Bar与Foo建立联系
1. 建立联系方式1：
```javascript
function Foo(name) {
    this.name = name;
}
Foo.prototype.myName = function() {
    console.log(this.name);
};
function Bar(name,label) {
    Foo.call( this, name );
    this.label = label;
}
//建立Foo与Bar的联系
Bar.prototype = Foo.prototype;
Bar.prototype.myLabel = function() {
    console.log(this.label);
};
var a = new Bar( "a", "obj a" );
a.myName(); // "a"
a.myLabel(); // "obj a"
console.log(Foo.prototype.myLabel); // function () {console.log(this.label);}
```
	- 主要问题是Bar.prototype直接饮用Foo.prototype，这样会为Foo.prototype添加myLabel方法，这并不是想要的
1. 建立联系方式2：
```javascript
function Foo(name) {
    this.name = name;
}
Foo.prototype.myName = function() {
    console.log(this.name);
};
function Bar(name,label) {
    Foo.call( this, name );
    this.label = label;
}
//*********************
Bar.prototype = new Foo();
Bar.prototype.myLabel = function() {
    console.log(this.label);
};
var a = new Bar( "a", "obj a" );
a.myName(); // "a"
a.myLabel(); // "obj a"
```
	- 通过new创建联系，会有一些副作用， 如果函数 Foo 有一些（ 比如写日志、 修改状态、 注册到其他对象、 给 this 添加数据属性， 等等） 的话， 就会影响到 Bar() 的“ 后代”， 后果不堪设想
1. 最合适的创建联系：
```javascript
function Foo(name) {
    this.name = name;
}
Foo.prototype.myName = function() {
    console.log(this.name);
};
function Bar(name,label) {
    Foo.call( this, name );
    this.label = label;
}
//*********************
Bar.prototype = Object.create(Foo.prototype);
Bar.prototype.myLabel = function() {
    console.log(this.label);
};
var a = new Bar( "a", "obj a" );
a.myName(); // "a"
a.myLabel(); // "obj a"
```
    - 要创建一个合适的关联对象， 必须使用 Object.create(..)
1. 修改对象的 [[Prototype]] 关联
    - ES6 之前
        - 设置 .__proto__ 属性来实现
            - 不是标准方法，并不完全兼容
        - ```Bar.ptototype = Object.create( Foo.prototype )```;
            - 让Bar抛弃默认的Bar.prototype
    - ES6
        - Object.setPrototypeOf( Bar.prototype, Foo.prototype );
1. 检查“类”关系
    - a instanceof Foo
        - 在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象
        - 只能处理对象（ a） 和函数（ 带 .prototype 引用的 Foo） 之间的关系，不能处理两个对象之间关系
    - b.isPrototypeOf( c );
        - b 是否出现在 c 的 [[Prototype]] 链中？
    - Object.getPrototypeOf( a );
        - 获取一个对象的 [[Prototype]] 链
    - a.__proto__
        - 通过  _proto_属性来获取[[[prototype]]链
        - 不是所有浏览器都支持
1. Object.create(null)
    - 创建空[[prototype]]链接的对象
    - 因为原型链是空，故instance任何对象都为false
    - 因为不受原型链影响，非常适合数据存储


# 行为委托
## 面向委托的设计
1. 类理论
    - 创建基类，写共有方法和属性
    - 子类重写
    - 创建实例，复制类行为
1. 委托理论
    - 可以任意方向委托关联，不像类与子类，只能是垂直方向
    - 调试:js并未控制浏览器开发者工具对特定值或结构的表示方式,如
```javascript
function Foo() {}
var a1 = new Foo();
a1; // Foo {}
```
        - chrome
            - 输出：Foo {}
            - Chrome 实际上想说的是“ {} 是一个空对象， 由名为 Foo 的函数构造”
            - Chrome 内部跟踪（ 只用于调试输出）“ 构造函数名称”
        - Firfox
            - 输出：Object {}
            - Firefox 想说的是“ {}是一个空对象， 由 Object 构造”

## 比较思维模型
1. 面向对象风格
```javascript
function Foo(who) {
    this.me = who;
}
Foo.prototype.identify = function() {
    return "I am " + this.me;
};
function Bar(who) {
    Foo.call( this, who );
}
Bar.prototype = Object.create( Foo.prototype );
Bar.prototype.speak = function() {
    console.log( "Hello, " + this.identify() + "." );
};
var b1 = new Bar( "b1" );
var b2 = new Bar( "b2" );
b1.speak();
b2.speak();
```
![][1]

    - 考虑思维图，因为Foo和Bar都是函数，必定隐含链接到Function.prototype
    - 函数又是Object，链接到Object.prototype
    - 虽然有些是不必要的，但去除后，依然很复杂
1. 面向委托风格
```javascript
Foo = {
    init: function(who) {
        this.me = who;
    },
    identify: function() {
        return "I am " + this.me;
    }
};
Bar = Object.create( Foo );
Bar.speak = function() {
    console.log( "Hello, " + this.identify() + "." );
};
var b1 = Object.create( Bar );
b1.init( "b1" );
var b2 = Object.create( Bar );
b2.init( "b2" );
b1.speak();
b2.speak();
```
![][2]

    - 这种代码只关注一件事： 对象之间的关联关系。
    - 需要那些既复杂又令人困惑的模仿类的行为（ 构造函数、 原型以及 new）。

## 类与对象
1. 通过学习，可以创建如UI控件，不用任何“类”辅助库或语法的情况下
1. 可以使用ES6的class，但这个也是根据[[Prototype]]机制实现的，只是精简了语法
1. 利用委托关系创建，即主要不使用prototype



[1]:./img/7-1.png
[2]:./img/7-2.png

