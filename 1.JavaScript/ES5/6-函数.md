# 函数
## 概述
1. 函数是设计用于执行特定任务的子程序。
1. 函数实际上是对象，每个函数是Function类型的实例，函数名实际是指向函数对象的指针
1. 函数是可调用对象
1. 函数总会返回一个值
  - 不指定返回值，函数无return语句，函数返回undefined
  - return后不带任何返回值，函数返回undefined
  - 位于return后的代码永远不会执行
1. 函数两种定义方式：函数声明与函数表达式

## 内部属性

### arguments对象

1. 函数参数在函数内部可理解为一个数组，函数体内用arguments对象来访问这个参数数组
2. arguments对象使用`Array.prototype.slice()`转化为数组
3. arguments与命名参数一同使用，对arguments[1]，会改变第二个参数值
4. arguments与命名参数值保持同步，但两者内存是独立的

### this

1. this引用的是函数的执行环境对象

### caller

1. caller：函数对象的属性，调用当前函数的函数的引用

## 属性和方法

### length

1. 函数希望接收的命名参数的个数，函数定义时的命名参数个数

### prototype

1. prototype是保存所有实例方法的真正所在
2. 属性是不可枚举的，无法用for-in发现

### call()

1. 在特定作用域上调用函数，实际是设置函数体内this对象的值
2. 两个参数：一个是运行函数作用域，另一个是参数数组

### apply()

1. 与apply主要区别是，第一个参数是运行函数作用域，其余参数是直接传递给函数的参数
2. 与call()主要区别：看给函数传递参数的方式
3. 与call()主要作用：扩充函数的运行作用域

### bind()

1. ES5定义的方法
2. 创建一个函数的实例，其this值会被绑定到传给bind()函数的值

### toString()

1. 返回函数的代码，不同浏览器可能存在差异

## 理解参数
1. ES函数不介意传入多少个参数，也不在乎传入的数据类型
1. ES的命名参数只是提供便利，但不是必须的
1. 没有传递的命名参数会被自动赋值为undefined
1. 由于ES中函数名本身是变量，所以函数也可作为值来使用，即可以像传递参数一样把一个函数传递给另一个函数



## 没有重载
1. 没有函数签名，真正意义的重载是不可能做到的
1. 将函数名理解为指针，有助于理解ES没有重载的概念
1. 但用arguments可以模拟

# 函数声明

## 概述

1. 函数声明：`function a (){}`
2. 特点：函数声明会提升，可以在声明前调用函数
3. 解析器会先读取函数声明，并使其在执行任何代码之前可用
4. 最好先声明函数再调用，而不是利用函数提升



# 函数表达式
## 概述
1. 函数表达式：`var a = function(){}`
2. 使用前必须先赋值
3. 函数表达式，必须等到解析器执行到它所在的代码行，才会被解析到

## 具名函数表达式

1. 具名的函数表达方便调试

2. 具名函数只是将一个名字附加在函数上，并不意味着可以它使用调用函数，如

	```javascript
	var addVariable = function addFunction(param1, param2) {
	    return param1 + param2 ;
	}
	var result = addFunction(num1, num2); 
	// ==> Uncaught ReferenceError: addFunction is not defined
	```

3. 但`addFunction`，可以在函数内部使用

	```javascript
	var addVariable = function addFunction(param1, param2) {
	    if(param1 === 0) {
	      param1 = addFunction(1,param2);
	    }
	    return param1 + param2 ;
	  };
	addVariable(0,2) // 5;
	```


## 递归
1. 递归使用函数名可能会出错
```javascript
function foo(num) {
    if(num <= 1){
        return 1;
    }else{
        return num* foo(num-1)
    }
}
console.log(foo(4)); //24
var bar = foo;
foo =null;
console.log(bar(4)); //Uncaught TypeError: foo is not a function
```

1. 使用arguments.callee
    - 指向正在执行的函数的指针，可以用来实现对函数的递归调用，虽然使用此方法能避免上述问题
    - 官方建议是：当一个函数必须调用自身的时候, 避免使用 arguments.callee(), 通过要么给函数表达式一个名字,要么使用一个函数声明
    - 严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误，可以使用命名函数表达式来达成相同的结果

# 立即执行函数（IIFE）

## 概述

1. 函数有一个功能是将一段代码包裹起来，避免污染当前作用域
2. 但函数依然存在问题：
	- 创建函数本身如foo，这个标识符污染了当前作用域
	- 需要foo()才能运行这段代码
3. 利用立即执行函数表达式可以解决上述函数问题
4. 立即执行函数（Immediately Invoked Function Expression，IIFE）
5. IIFE中声明的任何变量对外部都不可见

## IIFE的形式

1. 形式1：

	```javascript
	!function() {
	    alert("Hello from IIFE!");
	}();
	```

	- 如function出现在最前面，则会认为是函数声明
	- `!`是为了让js引擎认为这个function是一个函数表达式
	- 同样的一元操作符+、-、~、void都可以起到类似的效果
	- 但这样的方式不能获取IIFE的返回值

2. 形式2：

	```javascript
	// Variation 1
	(function() {
	    alert("I am an IIFE!");
	}());
	
	// Variation 2
	(function() {
	    alert("I am an IIFE, too!");
	})();
	```

	- 深入问题本质，两个版本略有不同，但从实际目的出发，选用哪种都可以

## 传入参数

1. 传入参数主要目是可以让参数在当前作用域查找，而不需向上查找

	```javascript
	var a = 123;
	// Variation 1
	(function(w) {
	    alert(w.a);
	    alert(window.a);//其实此处直接用window对象，也可以返回window.a的值
	}(window));
	
	// Variation 2
	(function(w) {
	    alert(w.a);
	})(window);
	```

2. 注意：

   - 声明以（funtion。。。开始，函数会被当作函数表达式而不是一个标准的函数声明来处理
	- function出现在声明第一个词则为函数声明，否则为函数表达式(上面第一个词为`(`左边括号)

## IIFE与闭包

1. 通过IIFE与闭包可以保存数据

  ```javascript
  var Sequence = (function sequenceIIFE() {
      // Private variable to store current counter value.
      var current = 0;    
      // Object that's returned from the IIFE.
      return {
          getCurrentValue: function() {
              return current;
          },        
          getNextValue: function() {
              current = current + 1;
              return current;
          }
      };
      
  }());
  
  console.log(Sequence.getNextValue()); // 1
  console.log(Sequence.getNextValue()); // 2
  console.log(Sequence.getCurrentValue()); // 2
  ```




# 提升
##　概述
1. js代码执行时并不是由代码编写顺序上到下一行一行执行的
1. 变量和函数在内的所有声明都会在任何代码执行前首先被处理
1. 只有声明会被提升，赋值或其他运算逻辑留在原地
1. 每个作用域都会对函数进行提升
1. 多次声明同一变量，后面声明的变量会视而不见，但会执行后面声明中的变量初始化

## 函数声明会提升，函数表达式不会
1. 注意1：

	```javascript
	foo(); // 不是 ReferenceError, 而是 TypeError!
	var foo = function bar() {
		// ...
	};
	```

2. 声明提升后会变为

	```javascript
	var foo;
	foo(); // 不是 ReferenceError, 而是 TypeError!
	foo = function bar() {
		// ...
	};
	```

	- 故foo调用时，foo还未赋值，是undefined，无法函数调用

3. 具名函数表达式，名称标识符在赋值之前也无法在所在的作用域中使用

	```javascript
	foo(); // TypeError，有声明，未赋值
	bar(); // ReferenceError，未声明
	var foo = function bar() {
	    // ...
	};
	```

## 函数优先
1. 函数与变量声明都会被提升，函数首先被提升

	```javascript
	foo(); // 1
	var foo;
	function foo() {
		console.log( 1 );
	}
	foo = function() {
		console.log( 2 );
	};
	```

	- 函数首先提升，提升完后，变量提升，这时候发现有个foo函数声明，会忽略变量声明
	- 但如何后面还有函数声明，会覆盖先前的函数声明

2. 一个普通块内部的函数声明通常会被提升到所在作用域的顶部

	```javascript
	foo(); // "b"
	var a = true;
	if (a) {
	 	function foo() { console.log("a"); }
	}
	else {
	 	function foo() { console.log("b"); }
	}
	```

	- 为避免js之后版本变化，不要在块内部声明函数



