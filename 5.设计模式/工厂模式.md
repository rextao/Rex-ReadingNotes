# 概述

1. js中任何函数可以返回一个对象，当返回值不是constructor函数或class时，称为工厂函数

# 工厂模式与Class对比

## 工厂模式代码

```javascript
function TodoModel(){
    var todos = [];
    var lastChange = null;

    function addToPrivateList(){
        console.log("addToPrivateList"); 
    }
    function add() { console.log("add"); }
    function reload(){}

    return Object.freeze({
        add,
        reload
    });
}
const model = TodoModel();
```



## Class

```javascript
class TodoModel {
    constructor(){
        this.todos = [];
        this.lastChange = null;
    }

    addToPrivateList(){
        console.log("addToPrivateList"); 
    }
    add() { console.log("add"); }
    reload(){}
}
const model = new Model();
```



## 对比

### 封装性

1. class方式所有属性与方法都是公有的

	```javascript
	var todoModel = new TodoModel();
	console.log(todoModel.todos);     //[]
	console.log(todoModel.lastChange) //null
	todoModel.addToPrivateList();     //addToPrivateList
	```

2. 工厂模式可以构建私有变量，即将要私有的变量与方法不放在返回对象中

### this问题

1. class模式中使用this，故会有this引用的问题，如setTimeout、回调，利用箭头函数可以解决
2. 工厂模式不使用this（工厂模式内部的this不指向实例），直接使用变量，故没有此问题

### 不可变api

1. 工厂模式使用Object.freeze返回对象，使共有函数不可变（但私有变量是可变的）
2. class可以使用`Object.freeze(TodoModel.prototype)`实现不可变对象

### new操作符

1. class缺点：必须使用new，不使用会报错
2. 工厂模式可以理解为构造函数内部强行return一个对象，而不是将this返回

### 内存使用

1. class是基于prototype，故多个实例共用一个方法
2. 当实力数量很多时，工厂模式会消耗较大的内存

## 小结

1. 工厂函数虽然不是创建安全的、封装的和灵活的OOP对象的更好选择，但是提供了编程思路