# 概述

1. 浏览器内核又可以分为两部分：渲染引擎（Layout Engine或Rendering Engine）和JS引擎。
2. 由于JS引擎越来越独立，内核就倾向于只指渲染引擎。 



# 浏览器构成

1. 浏览器通常由如下七个部分组成

   ![1546439861183](1-浏览器基础.assets/1546439861183.png)

2. **用户界面（User Interface）：** 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示请求的页面外，其他显示的各个部分都属于用户界面。

3. **浏览器引擎（Browser engine）：** 是浏览器中各个部分之间相互通信的核心。

4. **呈现（渲染）引擎（Rendering engine）：** 负责显示请求的内容，并将内容排版到浏览器中显示成有样式的界面。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上，也叫排版引擎

5. **网络功能模块（Networking）：** 用于网络调用

6. **用户界面后端（UI Backend）：** 用于绘制基本的窗口小部件，比如组合框和窗口。在底层使用操作系统的用户界面方法。

7. **JavaScript 解释器（Javascript Interpreter）：** 用于解析和执行 JavaScript 代码。

8. **数据存储（Data Persistence）：** 持久层。例如 Cookie、localStorage。

# 浏览器进程

## 构成

1. `Browser`进程：浏览器的主进程（负责协调，主控），只有一个，作用有：
	- 负责浏览器的界面显示，与用户交互，如前进，后退等
	- 负责各个页面的管理，创建和销毁其它进程
	- 将`Rendered`进程得到的内存中的`Bitmap`,绘制到用户界面上
	- 网络资源的管理，下载
2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。
3. `GPU`进程：最多一个，用于`3D`绘制等。
4. 浏览器渲染进程（浏览器内核）（`Render`进程，内部是多线程的）：默认每个`Tab`页面一个进程，互不影响。主要作用为：
	- 页面渲染，脚本执行，事件处理等

## 多进程优势

1. 在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）
2. 如果浏览器是单进程的，那么某个tab页挂了，整个浏览器会挂，某个插件挂了，浏览器会挂，用户体验很差
3. 多进程是浏览器用空间换时间，内存会消耗大一些

# 渲染引擎

## 介绍

### Trident(IE内核)  

1. IE内核，代表产品Internet Explorer，是微软开发的一种排版引擎
2. 国内很多的双核浏览器其中之一就是Trident，美名其曰“兼容模式” 

### Gecko（Firefox） 

1. Netscape、Firefox的网页排版引擎

### Webkit（Safari）  

1. 苹果公司自己的内核，代表作品Safari和Chrome
2. 特点在于源码结构清晰、渲染速度极快。
3. 缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示 

### Presto（Opera）  

1. Presto内核代表作品Opera 
2. 在13年之后，Opera宣布加入谷歌阵营，弃用了Presto 

### Blink（Chrome）

1. 现在Chrome内核是Blink。
2. Blink其实是webkit的分支，大部分国产浏览器最新版都采用Blink内核。 

## 渲染流程

### webkit渲染过程

![1558426842404](1-浏览器基础.assets/1558426842404.png)

### Gecko渲染过程

![1558426863101](1-浏览器基础.assets/1558426863101.png)

### 渲染基本流程

1. HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
2. 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
3. 生成布局（flow），计算元素位置、尺寸
4. 将布局绘制（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给`GPU`，`GPU`会将各层合成（`composite`硬件加速）,显示在屏幕上

### css加载阻塞dom渲染

1. 根据流程可知，dom与css解析是两个并行过程，故css不会阻塞dom解析
2. 但由于render tree依赖于dom tree与cssdom tree，故需要css加载完，才能生成，故css加载会阻塞dom渲染
3. 换个角度理解：加载css后又对dom节点样式进行了修改，如css加载不阻塞render树渲染的话，css加载完，render树会重新重绘或回流，造成性能浪费

## 重排(reflow)

### 概述

1. 又称之为回流，就好比向河里(文档流)扔了一块石头(dom变化)，激起涟漪，然后引起周边水流受到波及，所以叫做回流
2. 主要是dom尺寸位置的变化，浏览器需要重新计算元素的几何属性，重新安排布局
3. 重绘由于是外观改变，故"重绘"不一定会出现"重排"，"重排"必然会出现"重绘"

## 重绘(repaint)

### 概述

1. 当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘

## 浏览器渲染队列

1. 对于如下代码，会产生多次重排与重绘

	```css
	var s = document.body.style;
	s.padding = "2px"; // 回流+重绘
	s.border = "1px solid red"; // 再一次 回流+重绘
	s.color = "blue"; // 重绘
	s.backgroundColor = "#ccc"; // 重绘
	s.fontSize = "14px"; // 再一次 回流+重绘
	```

2. 浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，进行批处理，让多次的回流、重绘变成一次回流重绘。

3. 但对于`offsetHeight/offsetTop;scrollTop/Left;clientTop/Left；width/height`这些获取宽高方法或getComputedStyle()方法，会提前flush队列，如

	```css
	var s = document.body.style;
	s.padding = "2px"; // 回流+重绘
	console.log(div.offsetHeight)
	s.border = "1px solid red"; // 再一次 回流+重绘
	console.log(div.scrollTop)
	s.color = "blue"; // 重绘
	```

	- 这样浏览器就不会对重排和重绘进行优化

## 重排重绘优化

### 分离读写操作

1. 如上面渲染队列介绍，可以分离读写操作

	```css
	var s = document.body.style;
	s.padding = "2px"; // 回流+重绘
	s.border = "1px solid red"; // 再一次 回流+重绘
	s.color = "blue"; // 重绘
	console.log(div.scrollTop)
	console.log(div.offsetHeight)
	```

2. 这样，前面的设置属性，浏览器会利用渲染队列进行优化

### 样式集中改变

1. 可以将样式变为集中改变，如使用class或cssText

	```css
	// good 
	el.className += " theclassname";
	// good
	el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
	```

### 隐藏操作的dom

1. display:none的元素不会触发重排和重绘

### 利用DocumentFragment

1. 批量操作dom，这样只触发一次重排

### postion属性是absolute或fixed

1. 重绘开销比较小，不用考虑它对其他元素的影响

### 动画速率选择

1. 如1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源
2. 实现动画最好设置absolute或fixed，不影响其他布局

### 慎重选择高消耗的样式

1. box-shadows、border-radius、transforms、CSS filters（性能杀手）