# 字符串

## 概述

### 定义

1. 串（string）：是由零或多个字符组成的有限序列，又名字符串
2. 串中的每个成员称为字符
3. 所谓序列，说明串相邻字符之间具有前驱和后继的关系
4. 术语
  - 相等：长度相等，且对应字符都相同
  - 空串：长度为0的串，注意与由空格组成的串不同
  - 前缀：字符串s最靠前的k个字符
  - 后缀：字符串s最靠后的k个字符
  - 真子串、真前缀、真后缀：长度严格小于原串的子串、前缀、后缀

### 抽象数据类型（ADT）

1. 串的逻辑结构与线性表很相似，不同之处是串针对的字符，即字符集
2. 通常，字符种类不多，而串长很长
	- 比如英文文章，就是a-z加上标点，字符种类很少，但字符串长度要远远大于字母表长度
3. 串的操作与线性表差别也很大；线性表更关注单个元素的操作，如查找一个元素，插入或删除元素；串更多的是找子串位置，替换子串等操作
4. 其实串匹配问题，主要就是如何高效的实现indexOf接口

### 串的存储方式

1. 顺序存储
2. 链式存储：与线性表区别是：并不是每一个节点存储一个字符，这样会浪费很多空间；一般一个节点存储一个字符串，但存储多少比较合适，需要根据实际分析
3. 链式存储在连接串与串操作有一定方便外，总的来说不如顺序存储灵活，性能好

## 串匹配

### 概述

1. 串匹配根据难度不同，可以分为如下：
	- 只关心匹配串是否在文本中出现，如查找病毒，只是看文件中是否有病毒的关键码
	- 定位：文本出现在哪
	- 出现次数
	- 枚举问题：文本出现多次，每次出现在哪些位置
	- 关键是：定位问题，如能高效的找到文本在哪，出现次数以及枚举问题则会高效

### 编码方式

1. 常用编码集是标准的ASCII编码；7位二进制数表示一个字符，总共128个
2. 后来一些特殊的符号出现，使用扩展ASCII编码；8位二进制数，总共256个
3. 包含中文等多国符号，Unicode编码，16位二进制数；前256与AscII一致；

### 串如何比较

1. 通过组成串的字符之间的编码来进行的
2. 字符的编码指的是字符集中字符的序号

## 朴素的模式匹配算法

### 模式匹配

1. 子串的定位操作通常称为模式匹配；串中比较重要的操作
2. 如要在goodgoogle中查询google的位置，需要循环外面的goodgoogle，再循环google，不停比较每一个位置是否一致，来决定是否匹配

![image27](4-串(字符串).assets/image27.png)

### 代码实现

#### 方式1

```javascript
function match(p,s){
    let i = 0; // 匹配字符串,匹配成功就是i=p.length
    let j = 0; // 主串位置
    while (i < p.length && j< s.length) {
        if(p[i] === s[j]){
            i++;
            j++;
        }else{
            j = j - i + 1; // 相当于主串+1
            i = 0;
        }
    }
    // 如i到达p.length，退出循环，则匹配成功，
    // j = s.length，退出循环，匹配失败
    if(i === p.length) {
        return j - i;
    } else {
        return -1;
    }
}
```

#### 方式2 

```javascript
function match(p,s){// p 匹配字符串，s主串
    let j = 0; // i匹配字符串,匹配成功就是i=p.length
    let i = 0;// j主串位置
    const pLen = p.length;
    const sLen = s.length;
    // 主串只需要匹配到sLen - pLen + 1即可
    for( ;j < (sLen - pLen + 1);j++ ) {
        for(; i < pLen; i++ ){
            // 有不匹配字符直接返回
            if(s[i+j] !== p[i]) {
                break;
            }
            if(i === pLen -1 ){
                return j;
            }
        }
    }
    return -1;
}
```

### 性能分析

1. 假设匹配串长度为m，主串长度为n
2. 最好情况：经过一轮比对就可以获得结果，即循环m次，时间复杂度为O(m)
3. 最坏情况：每轮匹配都到末尾失败
	- 每轮循环：比对 = m-1(成功) +1 (失败) = m
	- 循环次数：n-m+1
	- 故最坏比对 $m*(n-m+1)$，但一般一般$n>>m$，故时间复杂度为O(n*m)
	- 效率低的主要原因是，此算法没有有效的避免这些匹配的情况
4. 如字符串会被处理为二进制形式，进行匹配，可能主串为00000000000000000000000001,匹配的为0001，循环到最后才能匹配到
5. 匹配字符集总数（如二进制只有0,1，但英文有26个）越少，最坏情况出现的概率越高
   - 当字符集增大，最坏情况出现的概率会急剧下降
   - 因此每个比对位置只需要常数次比对
   - 从期望角度看， 此算法能接近线性或达到线性
6. 匹配字符m越长，最坏情况的后果更加严重

## KMP模式匹配算法

### 算法原理

1. 通过每次移动多于1位比较，减少比较次数
2. 一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是\"ABCDAB\"。KMP算法的想法是，设法利用这个已知信息，不要把\"搜索位置\"移回已经比较过的位置，继续把它向后移，这样就提高了效率。![image28](4-串(字符串).assets/image28.png)
   - 虽然前六个字符匹配，第七个字符不匹配，并不能将匹配字符直接挪到第7位置开始匹配
   - 应该挪动到AB这个位置，即主串与子串有重复的部分
3. 怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。![image29](4-串(字符串).assets/image29.png)
4. 已知空格与D不匹配时，前面六个字符\"ABCDAB\"是匹配的。查表可知，最后一个匹配字符B对应的\"部分匹配值\"为2，因此按照下面的公式算出向后移动的位数：
	- 移动位数 = 已匹配的字符数 - 对应的部分匹配值
	- 因为 6 - 2 等于4，所以将搜索词向后移动4位。
5. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（\"AB\"），对应的\"部分匹配值\"为0。所以，移动位数2，于是将搜索词向后移2位。![image30](4-串(字符串).assets/image30.png)
6. 因为空格与A不匹配，继续后移一位。![image31](4-串(字符串).assets/image31.png)
7. 逐位比较，直到发现C与D不匹配。于是，移动位数$ = 6 - 2$，继续将搜索词向后移动4位。![image32](4-串(字符串).assets/image32.png)
8. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。

![image33](4-串(字符串).assets/image33.png)

### 部分匹配值获取

1. 主要是理解为何可以先对匹配串进行预处理获取next表

#### 概述

1. 假设，首次主串与匹配串在T[i]和P[j]这个位置不匹配（X与Y不匹配），需要如何移动匹配串，从而等效的以?号处字符与X对齐，并从这个位置开始新的匹配。？号的位置可以事先确定，并指取决于模式串，而与主串无关？why？![1545308012269](4-串(字符串).assets/1545308012269.png)
2. 在首次匹配失败时，根据上图，我们可以将主串分为4部分，前缀，匹配成功的($T[i-j,i]​$)，匹配失败的X，和后缀($T(i,n)​$)，而前缀与后缀对于新的?号处的值无关，故匹配成功的($T[i-j,i]​$)串会决定？号处的值
3. 匹配成功的($T[i-j,i]$)会影响？号处的值，而匹配成功的($T[i-j,i]$)的串和匹配串($P[0,j]$)是完全一样的，故可以说是匹配串决定了?号的值
4. 与其说，？号字符取决于模式串，不如说它取决于之前的Y值
5. 而在长度为m的匹配字符串中，Y有m种情况
6. 因此KMP算法实际是构造了一个next[0,m]的表，在任意位置P[j]处理失败了，将j替换为next[j]值

### Next数组

#### 概述

1. 蓝色为主串；黄色为当匹配到j时，发生误配；红色表示KMP算法移动t后的；![1545309158050](4-串(字符串).assets/1545309158050.png)
2. 由于误配发生在j处，那么黄色和蓝色应该是匹配的；
3. 红色挪动t个字符，红色前缀$P[0,t)​$与蓝色后缀$P[j-t,j]​$匹配
4. 因此可以认为，在j处发生误配，黄色的匹配串，首部和尾部必须要有一定的相似度
5. 即是$P[0,t]==P[j-t,j]$![1545309529014](4-串(字符串).assets/1545309529014.png)

#### 避免回溯

1. 对于上述分析，匹配串满足$P[0,t]==P[j-t,j]​$，t的值并不唯一
2. 因为$j-t$为位移量，t越小，位移就越大，位移量更小，意味着某种意义上的更安全，可以避免回溯
3. KMP选取最大的t值，保证最小的位移，保证位移量是安全的和由KMP舍弃的位置确实是不值得对齐的

#### 通配哨兵

1. 由上面得到，对于任意j，考察集合$N(P,j) = \{ 0 \leq t < j | P[0,t) == P[j-t,j)\}$，并非为空集，当j=0时，为空集，也就是空字符串
2. 为解决空集问题，KMP算法将next[0]设置为-1，假设这是一个通配符，与任何字符串都匹配
3. 比对失败于首字符P[0]，然后KMP算法利用假想的这个通配符-1与主串T[i]继续比对，既然是通配符，则匹配成功
4. 故最终得到![image35](4-串(字符串).assets/image35.png)

#### 构造next数组

1. 利用递推的的方式，即假设已知的$next[0,j]$，如何高效的计算出next[j+1]
2. 
3. \"部分匹配值\"就是\"前缀\"和\"后缀\"的最长的共有元素的长度。以\"ABCDABD\"为例
  - \"A\"的前缀和后缀都为空集，共有元素的长度为0；
  - \"AB\"的前缀为\[A\]，后缀为\[B\]，共有元素的长度为0；
   - \"ABC\"的前缀为\[A, AB\]，后缀为\[BC, C\]，共有元素的长度0；
   - \"ABCD\"的前缀为\[A, AB, ABC\]，后缀为\[BCD, CD,D\]，共有元素的长度为0；
   - \"ABCDA\"的前缀为\[A, AB, ABC, ABCD\]，后缀为\[BCDA, CDA, DA,A\]，共有元素为\"A\"，长度为1；
   - \"ABCDAB\"的前缀为\[A, AB, ABC, ABCD, ABCDA\]，后缀为\[BCDAB, CDAB,DAB, AB, B\]，共有元素为\"AB\"，长度为2；
   - \"ABCDABD\"的前缀为\[A, AB, ABC, ABCD, ABCDA,ABCDAB\]，后缀为\[BCDABD, CDABD, DABD, ABD, BD,D\]，共有元素的长度为0。

![image34](4-串(字符串).assets/image34.png)

### Next数组

1. 主要解决计算机如何实现部分匹配值数组
2. 构造next数组，j表示要匹配的字符串挪动的位置
3. T=abcabx![image36](4-串(字符串).assets/image36.png)
    - j=1时，根据上述公式，next\[1\] = 0
    - j=2时，j由1到j-1串只有字符a，属于其他情况，故next\[2\]=1
    - j=3时，字符串为ab，属于其他情况，next\[3\] = 1
    - j=4时，字符串为abc，next\[4\] = 1
    - j=5时，字符串为abca，前缀字符a与后缀字符a相等，故p1=p4，得到k=2，故next\[5\] = 2
    - j=6时，字符串为abcab，其中p1p2 = p4p5,故k=3，即next\[6\] = 3


4. next值使用
    - 匹配字符串为abcabx，主串为abcabcabc，如下，开始时，直到主串匹配到i=6，j=6时，才发现不匹配，现在需要挪动子串![image37](4-串(字符串).assets/image37.png)
    - 朴素的模式匹配是将匹配字符串向后挪动1位，再匹配；这样是不必要的![image38](4-串(字符串).assets/image38.png)
    - KMP算法则是根据next数组，来判断移动位置数，根据数组可以得到j=6时，next\[6]= 3，因此需要在匹配字符串j=3开始匹配；即不再回溯主串![image39](4-串(字符串).assets/image39.png)

5. 主串为aaaabcde与匹配串aaaaax
    - 匹配串的next数组为  012345
    - 开始匹配到主串i=5时，发现匹配不对，读取next数组；![image40](4-串(字符串).assets/image40.png)
    - 此时next\[5\]=4，因此，需要将子串挪动到j=4，将i=5与j=4的数据判断是否匹配；不匹配，再判断j=3；依次类推![image41](4-串(字符串).assets/image41.png)
    - 直到j=1判断不对，再挪动i=7再匹配子串![image42](4-串(字符串).assets/image42.png)

## 改进的KMP模式匹配算法

### 普通KMP算法的缺点

1. 对于主串为aaaabcde与匹配串aaaaax；这样的匹配中间有些过程是没有用的；如i=5时不匹配，根据next数组得知，当前j=4；但由于匹配串前4个都是a，i=5不匹配，前面i=4，i=3等都不匹配，没必要进行循环

### 新next推导

1. T=ababaaaba，next为KMP，nextval为改进的KMP![image27](4-串(字符串).assets/image43.png)
2. 计算出next数组为011234223
    - j=1时， nextVal\[1\] = 0
    - j=2时，由于b这个字符，需要next值为1，但next为1时，是a字符，不相等，保留原有next值，nextVal\[2\]=1
    - j=3时，此时字符为a，next为1，next为1时，字符为a，相等，使用之前的next值，因此nextVal[3]=0
    - j=4时，nextVal\[4\] = 1
    - j=5时，nextVal\[5\] =0
    - j=6时，此时字符a，next值为4，next值为4时，实际字符为b，故保留原有next值，nextVal\[6]= 4
