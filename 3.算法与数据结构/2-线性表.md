# 线性表

## 概念

1. **零个或多个数据元素的有限序列**

## 线性表的顺序存储方式

### 概述

1. 指的是用一段地址连续的存储单元依次存储线性表的数据元素
2. 可以使用数组来实现顺序存储结构

### 数组长度与线性表长度

1. 数组长度是存放线性表的存储空间长度，一般分配后是不变的；通过程序手段可以改变
2. 线性表长度是：线性表中数据的个数![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image9.png)
3. 对于此种存储结构，知道起始地址，则可以推断出任意位置的地址，此存储结构又称为随机存储结构

### 优缺点

1. 对于顺序存储的线性表，插入与删除数据，如插入或删除a\[4\]这个元素，都需要挪动后面全部元素，因此插入与删除的时间复杂度为O(n)
2. 存或读取数据的时间复杂度为O(1)
3. 因此这个结构适合元素个数变化不大的，更多是存取数据的应用

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image10.png)

## 线性表的链式存储方式

### 链表定义

1. 链表是一种递归的数据结构，它或者为空（null），或者指向一个节点的引用，该节点含有一个泛型的元素或者一个指向另一个链表的引用

### 单链表数据读取

1. 核心思想就是指针后移，要查询i，需要从a1，根据后续指针，找到a2，然后一直到ai，故时间复杂度为O(n)

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image11.png)

## 综述

### 优缺点比较

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image12.png)

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image13.png)

### 综述

1. 在结构化存储数据集时，链表是数组的一种重要的替代方式
2. 数组与链表常常称为是顺序存储与链式存储
3. 若线性表频繁查找，用顺序存储合适，若插入删除较多，用单链表存储合适，比如
	- 用户注册，之后大部分时间是读取，故使用顺序存储合适
	- 游戏用户的装备库，需要经常删除添加，使用单链表更合适
4. 如线性表元素并不知道有多少时，用单链表比较合适，这样不用考虑存储大小的问题

## 静态链表

### 概述

1. 其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法
2. 使用数组实现单链表能力，也叫游标实现法

### 设计思路

1. 把未使用的数组元素称之为备用链表
2. 需要提前设置数组长度；![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image14.png)
3. 数组`a[0].cur`表示的空余数组起始游标(即新数据应该放在哪)；每一个数组项，类似于`{data:'',cur:''}`；
	- data用于存储实际内容
	- cur用于存储下一项所在的数组游标位置

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image15.png)

### 插入操作

1. 如要在乙丁间插入，丙这个元素，即在i=3处插入
2. 因为不是顺序存储，不需要挪动元素，根据`a[0].cur`知道，当前空的游标为7，故将丙放到7这个位置上，并将`a[0].cur=8`
3. `a[2].cur= 7,a[7].cur=3`；实际是，通过cur表示当前元素后一个元素是数组哪一项，但数组元素未移动，数组只是用于放置元素而已

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image16.png)

### 删除操作

1. 对于原数组，删除甲这个元素
2. 甲元素删除后，a\[1\]空出来，因此a\[1\]为备用链表起始元素，故`a[0].cur=1`指向a[1]
3. `a[1].cur = 8 `这个8为之前`a[0].cur`的值

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image16.png)

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image17.png)

### 优缺点

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image18.png)

## 循环链表

1. 为了解决单向链表，只能从头元素遍历链表的缺陷；
2. 将单链表的终端节点的指针指向头节点，使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表
3. 主要解决：如何从链表中一个节点出发，访问链表的全部节点（单链表无法知道当前节点上一个节点是谁）

## 双向链表

1. 为了解决单向链表无法反向遍历链表的缺陷，或不能查找当前节点的前一个节点的缺陷
2. 单向链表有next指针，因此查找下一个节点的时间复杂度为O(1)；但查找前一个节点，需要遍历整个链表，时间复杂度为O(n)
3. 为每个节点增加一个prior指针，这样可以反向遍历查找，付出的代价是插入和删除节点时，需要更改两个指针变量，空间换时间

## 小结

1. 分类

![](../3.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/media/image19.png)

