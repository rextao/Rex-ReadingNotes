# 生成器
## 打破完整运行
### 概述
1. js代码普遍认识是：一个函数开始运行就会到结束，中间不会被打断或查出其他代码
    - ES6生成器摆脱了这个限制
```javascript
    var x = 1;
    function *foo() {
        x++;
        yield; // 暂停！
        console.log( "x:", x );
    }
    function bar() {
        x++;
    }
    var it = foo();
    it.next();
    bar();
    it.next(); //x: 3
```
    - var it =foo(）：构造一个迭代器，并未执行生成器*foo()
    - it.next()：启动生成器，运行*foo第一行x++；然后在yield暂停，但*foo扔处于活跃
    - bar()将x++
    - it.next()：再调用后，从*foo暂停处继续运行
1. 生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成

### 输入和输出
1. 既然生成器是特殊的函数，则具有函数基本特性（如有返回值，输入参数等）
```javascript
function *foo(x) {
    return x*x;
}
var it = foo(4);
console.log(it.next().value); // 16
console.log(it.next().done); // true,是否结束
```
    - 总是创建一个迭代器对象赋值给it，用于控制生成器*foo
    - it.next()：返回一个对象，持有*foo返回值和是否完成的状态
    - 每次调用it.next，会运行到yield处停止，故如想运行到结尾，需要调用next为yield次数+1
1. yield是双向传递信息的
```javascript
function *foo(x) {
    return x*(yield 3);
}
var it = foo(4);
console.log(it.next().value); // 3
console.log(it.next(5).value); // 20
```
    - it.next（）会将4传入*foo，暂停在yield处，返回yield值
    - 再次调用it.next(5)，会将参数值5，作为被暂停yield表达式的结果值
    - 为何第一个it.next没有传入参数值
        - 只有暂停的yield才能接受这个值，第一个调用，没有暂停的yield接受这个值
        - it.next()调用其实是在问*foo，我下一个值是什么？？yield表达式的值回答了它


### 多个迭代器
1. 每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例
1. 同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互
```javascript
var it1 = foo();
var it2 = foo();
```


## 生成器产生值
### 生产者与迭代器
1. 如何记录上一个值？
1. 采用闭包形式
```javascript
var gimmeSomething = (function(){
    var nextVal;
    return function(){
        if (nextVal === undefined) {
            nextVal = 1;
        }
        else {
            nextVal = (3 * nextVal) +6;
        }
        return nextVal;
    };
})();
console.log(gimmeSomething()); // 1
console.log(gimmeSomething()); // 9
console.log(gimmeSomething()); // 33
console.log(gimmeSomething()); // 105
```
1. 迭代器模式
    - 迭代器模式是解决这个问题的通用设计模式
```javascript
var something = (function(){
    var nextVal;
    return {
        [Symbol.iterator]: function(){ return this; },// for..of循环需要,对下面调用没什么作用
        next: function(){ // 标准迭代器接口方法
            if (nextVal === undefined) {
                nextVal = 1;
            }
            else {
                nextVal = (3 * nextVal) + 6;
            }
            return { done:false, value:nextVal };
        }
    };
})();
console.log(something.next().value); // 1
console.log(something.next().value); // 9
console.log(something.next().value); // 33
console.log(something.next().value); // 105
```
        - [ .. ] 语法被称为计算属性名
        - Symbol.iterator 是 ES6 预定义的特殊Symbol 值之一
        - 可以通过for..of循环具有迭代器的对象
            - 每次迭代调用next方法，直到接收done：true停止
        - something 对象叫作迭代器

### iterable
1. 可迭代的
    - ES6要求
        - 必须支持一个Symbol.iterator函数
        - 调用这个函数时，它会返回一个全新迭代器
1. for..of会自动调用Symbol.iterator
    - 同样，我们可以手动调用
```javascript
var a = [1,3,4,5,6];
var it = a[Symbol.iterator]();
console.log(it.next().value);
console.log(it.next().value);
console.log(it.next().value);
```

### 生成器迭代器
1. 生成器可以看做是一个值的生产者，通过调用迭代器的next获取值
```javascript
function *something() {
    var nextVal;
    while (true) {
        if (nextVal === undefined) {
            nextVal = 1;
        }
        else {
            nextVal = (3 * nextVal) + 6;
        }
        yield nextVal;
    }
}
for (var v of something()) {
    console.log( v );
    if (v > 500) {// 不要死循环！
        break;
    }
}// 1 9 33 105 321 969
```
    - 迭代器实现上述例子
    - 此处的something为生成器，但something()为迭代器(注意for..of循环中)，具有Symbol.iterator函数
    - 生成器会在yield处暂停，故*something的状态会被保存
    - 此方式要比闭包和iterator方式更简洁
1. 停止生成器
    - for..of 循环的“异常结束”（也就是“提前终止”），通常由 break、 return 或者未捕获异常引起，会向生成器的迭代器发送一个信号使其
    - 同样可以手动停止,如上述代码中的break，提前停止生成器

## 异步迭代生成器
1. 普通的回调模式
```javascript
function foo(x, y, cb) {
    ajax(
            "http://some.url.1/?x=" + x + "&y=" + y,
            cb
    );
}
foo(11, 31, function (err, text) {
    if (err) {
        console.error(err);
    }
    else {
        console.log(text);
    }
});
```
    - 回调模式代码转换为生成器
```javascript
    function foo(x, y) {
        ajax(
                "http://some.url.1/?x=" + x + "&y=" + y,
                function (err, data) {
                    if (err) {
                        it.throw(err);// 向*main()抛出一个错误
                    }
                    else {
                        it.next(data);// 用收到的data恢复*main()
                    }
                }
        );
    }
    function *main() {
        try {
            var text = yield foo(11, 31);
            console.log(text);
        }
        catch (err) {
            console.error(err);
        }
    }
    var it = main();
    it.next();    // 这里启动！
```
	- 通过yield暂停代码
```javascript
var text = yield foo(11, 31);
console.log(text);
```
    - yield此处不是用于信息传递，而是流程控制
    - it.next会暂停到yield处，虽然返回值是undefined的，但阻塞到此处，console不会输出
    - 调用foo函数，有数据后会将数据返回给yield，继续运行
1. 实现相同功能，生成器代码更多,但有好处
    - 生成器内代码看似完全同步，但实际foo是完全异步的
        - 这是完全符合思维模式的，不像回调
    - 本质是将异步实现抽象出，使我们可以用同步思维追踪程序流程
1. 同步错误处理
    - foo是异步处理的，main的try-catch能捕获到异常？
        - 精彩之处是：yield 暂停也使得生成器能够捕获错误
        - 等待foo完成，使得响应可以赋给text
    - yield 暂停的特性
        - 能从异步函数调用得到看似同步的返回值
        - 还可以同步捕获来自这些异步函数调用的错误
1. 生成器模式作用
    - 在异步代码中实现看似同步的错误处理（通过 try..catch）在可读性和合理性方面都是一个巨大的进步。

## 生成器 +Promise
1. 上述生成器相对于回调，在顺序性和合理性方面的巨大进步；但缺少了Promise 的可信任性和可组合性
1. ES6 中最完美的世界就是生成器（看似同步的异步代码）和Promise（可信任可组合）的结合
1. 将上述代码改写为生成器+promise模式
```javascript

    function foo(x,y) {
        return request(
                "http://some.url.1/?x=" + x + "&y=" + y
        );
    }
    function *main() {
        try {
            var text = yield foo( 11, 31 );
            console.log( text );
        }
        catch (err) {
            console.error( err );
        }
    }
    var it = main();
    var p = it.next().value;
    // 等待promise p决议
    p.then(
            function(text){
                it.next( text );
            },
            function(err){
                it.throw( err );
            }
    );
```
	- 生成器*main并未做改变，foo函数只是将回调模式的ajax，换用一个返回promise的request函数
    - 调用生成器后的迭代器，可以监听这个promise的决议，然后根据决议继续运行或停止生成器
    - 获得 Promise 和生成器最大效用的最自然的方法就是 yield 出来一个 Promise，然后通过这个 Promise 来控制生成器的迭代器
    - 此种方式实现的主要问题
    	- 实现循环控制，手工调用Promise链较为麻烦
        - it.next报错无法处理
1. 支持 Promise 的 Generator Runner
    - 为解决上述问题，有些库已经提供了上述Promise+生成器模式，故可能只需要run(main)即可

## 生成器委托
1. 概述
    - 一个生成器调用另一个生成器
```javascript
    function *foo() {
        console.log( "*foo() starting" );
        yield 3;
        yield 4;
        console.log( "*foo() finished" );
    }
    function *bar() {
        yield 1;
        yield 2;
        yield *foo(); // yield委托！
        yield 5;
    }
    var it = bar();
    console.log(it.next().value); // 1
    console.log(it.next().value); // 2
    console.log(it.next().value); // *foo() starting, 3
    console.log(it.next().value); // 4
    console.log(it.next().value); // *foo() finished,5
```
        - bar()生成bar迭代器，运行到第2个next
        - 当发出第3个next调用时，*foo启动，迭代器控制由bar交给foo
        - 一旦 it 迭代器控制消耗了整个 *foo() 迭代器， it 就会自动转回控制 *bar()。
        - yield * 暂停了迭代控制，而不是生成器控制
1. 为什么用委托
    - yield 委托的主要目的是代码组织，以达到与普通函数调用的对称
    - 保持生成器分离有助于程序的可读性、可维护性和可调试性
    - 因为有时可能单独调用*foo，有时需要*bar调用*foo
1. 消息委托
    - 理解yield信息流入流出顺序
```javascript
    function *foo() {
        console.log( "inside *foo():", yield "B" );
        console.log( "inside *foo():", yield "C" );
        return "D";
    }
    function *bar() {
        console.log( "inside *bar():", yield "A" );
        console.log( "inside *bar():", yield *foo() );
        console.log( "inside *bar():", yield "E" );
        return "F";
    }
    var it = bar();
    console.log( "outside:", it.next().value );      // outside: A
    console.log( "outside:", it.next( 1 ).value );   // inside *bar(): 1,outside:B
    console.log( "outside:", it.next( 2 ).value );   // inside *foo(): 2,outside:c
    console.log( "outside:", it.next( 3 ).value );   // inside *foo(): 3,inside *bar(): D, outside:E
    console.log( "outside:", it.next( 4 ).value );   // inside *bar(): 4,outside: F
```
    - yield 可以委托给非生成器
```javascript
    function *bar() {
        console.log( "inside *bar():", yield "A" );// yield委托给非生成器！
        console.log( "inside *bar():", yield *[ "B", "C", "D" ] );
        console.log( "inside *bar():", yield "E" );
        return "F";
    }
    var it = bar();
    console.log( "outside:", it.next().value );     // outside:A
    console.log( "outside:", it.next( 1 ).value );  // inside *bar():1,outside:B
    console.log( "outside:", it.next( 2 ).value );  // outside:c
    console.log( "outside:", it.next( 3 ).value );  // outside:D
    console.log( "outside:", it.next( 4 ).value );  // inside *bar(): undefined , outside:E
    console.log( "outside:", it.next( 5 ).value );  // inside *bar(): 5 , outside:F
```
		- 默认的数组迭代器并不关心通过next传递的消息，而且也没有显式的返回值
    - 错误和异常也是双向传递的
```javascript
    function *foo() {
        try {
            yield "B";
        }
        catch (err) {
            console.log( "error caught inside *foo():", err );
        }
        yield "C";
        throw "D";
    }function *bar() {
        yield "A";
        try {
            yield *foo();
        }
        catch (err) {
            console.log( "error caught inside *bar():", err );
        }
        yield "E";
        yield *baz();
        yield "G";  // 注：不会到达这里！
    }
    function *baz() {
        throw "F";
    }
    var it = bar();
    console.log( "outside:", it.next().value );       // outside : A
    console.log( "outside:", it.next( 1 ).value );    // outside : B
    console.log( "outside:", it.throw( 2 ).value );   // "error caught inside *foo():", 2 ;outside : C
    console.log( "outside:", it.next( 3 ).value );    // "error caught inside *bar():", D ;outside : E
    try {
        console.log( "outside:", it.next( 4 ).value );
    }
    catch (err) {
        console.log( "error caught outside:", err );  // "error caught outside:" F
    }
```

## 小结
1. 生成器为异步代码保持了顺序、同步、阻塞的代码模式
    - 使得大脑可以更自然地追踪代码，解决了基于回调的异步的两个关键缺陷之一
1. 生成器内部的代码是以自然的同步/顺序方式表达任务的一系列步骤
    - 把异步隐藏在yield后面，把异步移动到控制生成器的迭代器的代码部分
