# 错误处理
## try-catch
### 概述

1. 如try块中有任何语句抛出异常，则会转跳到catch子句
2. 如try块中没有异常，则跳过catch子句
3. 无论上述哪种情况，finally子句都会执行
4. try中的return、continue、throw会在finally语句执行之后执行

### finally子句

1. 在`try`块和`catch`块之后执行但是在下一个`try`声明之前执行

2. 如果从`finally`块中返回一个值，那么这个值将会成为整个`try-catch-finally`的返回值，无论是否有`return`语句在`try`和`catch`中。这包括在`catch`块里抛出的异常。

	```javascript
	function foo() {
	    try {
	        try {
	            throw new Error("oops");// 1
	        }
	        catch (ex) {
	            console.error("inner", ex.message);
	            throw ex;
	        }
	        finally {
	            console.log("finally");// 2
	            return
	        }
	    }
	    catch (ex) {
	        console.error("outer", ex.message); // 3
	    }
	}
	foo()
	```

	- 结果：inner oops,finally
	- 并不会显示：outer oops，如果将finally中return删除，会显示

3. 根据上述规则，finally的return语句会覆盖try-catch中的return语句

### 合理使用

1. 最适合处理那些我们无法控制的错误
2. 如使用大型js库中函数，可能有意无意的抛出错误，又无法改源码，可以使用try-catch

### 注意

1. 无法捕获语法错误，开发阶段会看到，不会到线上系统
2. 无法捕获异步错误，只能捕获同步错误

## 抛出错误

1. 与try-catch相配的还有throw操作符，用于随时抛出自定义错误
1. 遇到throw操作符，代码立即停止执行
1. 创建自定义错误
    - throw new SyntaxError("haha");
    - 利用原型链继承Error来创建自定义错误类型，需要指定name和message属性
1. 抛出错误的时机
    - 虽然函数执行错误，浏览器会报错，但不同浏览器会给出不同的错误信息
    - 错误信息并没有清楚的告诉到底什么问题，如何修复，可以自定义类型，抛出
1. 捕获错误：目的在于避免浏览器默认方式处理他们
1. 抛出错误：目的在于提供错误发生具体原因的信息

## 错误事件
1. 任何没有通过try-catch处理的错误都会触发window对象的error事件
1. 在任何web浏览器中，onerror事件处理程序都不会创建error对象
1. 要指定onerror事件处理程序，必须使用DOM0级技术，它没有遵循DOM2级事件的标准格式
1. 只要发生错误，无论是不是浏览器生成的，都会触发error事件
1. 浏览器使用这个事件处理错误的方式不同，IE会保留变量和数据，firefox会在事件发生之前销毁数据和变量
1. 图像的error事件
    - 如图像src的url不能返回可以识别的图像格式，就会触发error事件

## 常见的错误类型
### 概述

1. 错误处理的核心：首先要知道代码里发生什么错误
2. 因为js是松散类型，不会验证函数的参数，因此错误只会在代码期间出现

### SyntaxError

1. 语法错误

	```javascript
	// 变量名不符合规范
	var 1 ;//Uncaught SyntaxError: Unexpected number
	// 给关键字赋值
	function = 5 ;// Uncaught SyntaxError: Unexpected token =
	```

### ReferenceError

1. 引用错误：引用一个不存在的变量时发生的错误

	```javascript
	a();// Uncaught ReferenceError: a is not defined
	```

### RangeError

1. 范围错误：
	- 数组长度为负数，`[].length = -5`
	- 函数堆栈超过最大值
	- number对象的方法参数超过范围

### TypeError

1. 类型错误，变量或参数不是预期类型

### URIError

1. uri相关函数参数不正确`decodeURI('%2') `

### EvalError

1. 此异常不再被js抛出，但EvalError对象扔保持兼容

## 全局监控

### window.error

1. 当 JavaScript 运行时错误（包括语法错误）发生时，会执行 window.onerror()
2. 最好写在全部js脚本之前，否则可能捕获不到错误
3. 不能捕获语法错误以及静态资源错误

### window.addEventListener

1. 当一项资源（如 <img> 或 <script> ）加载失败，能被单一的 window.addEventListener 捕获

## 注意

### 问题

1. 在查看 JavaScript 错误统计时，发现 80% 以上都是 "script error"。
2. 由于脚本来源于第三方（如cdn），为了避免信息泄露，故不报告细节，用script error代替

### 解决

1. 添加CORS支持，页面脚本使用`<script src="//xxx.com/example.js" crossorigin></script>`
2. 服务器添加access-control-allow-origin



# 性能

## 提高性能

### 注意作用域

1. 随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加
1. 避免全局查找
    - 如要使用document.getElementById,100次
    - 需要在作用域链查找document100次，故可创建局部变量doc = document
1. 避免with语句
    - with会创建自己的作用域，因此会增加其中执行代码的作用域链的长度
    - 大部分情况下可以用局部变量代替

### 选择正确的方法
1. 避免不必要的属性查找
    - 避免不必要的属性查找
    - 访问字面值、存储在变量的值、数组，为O(1)，非常高效
    - 访问对象属性是O(n)操作，因为必须在原型链中对拥有该名称的属性进行一次搜索
    - 对象属性，可以根据点的个数确定属性查找的次数
    - 如多次用到对象属性，要存在局部变量中，第一次访问是O(n)，之后都是O(1)
1. 避免双重解释
    - 避免解析包含js代码的字符串
    - 如：new Function("alert('Hello world');");

### 优化DOM交互
1. js各个方面，DOM毫无疑问是最慢的一部分
1. 最小化现场更新
    - 一旦需要访问DOM部分是已经显示在页面的一部分，那么就进行了一个现场更新
    - 一旦需要更新DOM，可以考虑文档片段来构建DOM结构
1. 使用innerHTML
    - 使用innerHTML比标准DOM创建相同的DOM结构快
    - innerHTML设置值的过程
        - 后台创建一个HTML解析器
        - 使用内部DOM调用来创建DOM结构
        - 不是基于js的DOM调用
        - 由于内部方法是编译方法而非解释执行，执行更快
1. 使用事件代理
    - 根据事件冒泡，在更高层DOM设置事件处理程序
1. HTMLCollection
    - 任何时候访问HTMLCollection，无论是方法还是属性，都是在文档上进行一个查询
    - 何时返回一个HTMLCollection对象
        - 调用getElementByTagName()
        - 获取childNodes属性
        - 获取attribute属性
        - 访问特殊集合：document.forms,document.images等



# 测试

## 单元测试

### 意义

1. 如果API升级时，测试用例可以很好地􏶃查是否向下兼容

### 断言

1. 􏶠断言是单元􏴛测试中用来保证最小单􏴛是否正常的􏶃检测方法。
2. 是用于检测程序在运行时，是否满足期望
3. node存在assert模块，而市面上的断言库大多都是基于assert模块进行封􏱢和扩展的
4. 断言一􏰐􏶃查失败，将会抛出异常􏲀􏲿整个应用

### 测试框架

1. 测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试􏴋􏲎报告
2. 测试用例的不同组织方式
   - TDD测试驱动：所有功能是否被正确实现，每一个功能都具备对应的测试用例
   - BDD行为驱动：关注整体行为是否符合预期，适合自􏷈向下的设计方式

## 性能测试

### 􏰳􏸎􏵑􏵒基准测试

1. 基准测试要统计的就是在多少时间内执行了多少次􏱧某个方法，主要方法如下：
2. 使用new Date方式的缺陷
  - 由于浏览器精度问题，可能小于1ms或10ms，都会被显示为0
  - 无法确定每次都是相同的时间运行完
  	- 不知道系统或引擎是不是对时间有影响
  - end-start会有误差
  - 无法确定测试的环境是不是过度优化了，即本次测试js引擎找到了最优办法，实际环境则不行了
3. 重复
  - 如果将上面代码重复100次，求平均也是不行的
  	- 因为某处最优或最差可能影响最终结果
4. Benchmark.js
  - 任何有意义且可靠的性能测试都应该基于统计学上合理的实践
  - http://benchmarkjs.com/
  - 如想对代码进行功能测试和性能测试，这个库应该最优先考虑
  - 如果想得到可靠的测试结论的话，就需要在很多不同的环境进行测试
5. jsPerf.com
  - 可以实现多环境测试
  - 可以实现代码片段的性能测试

# 尾调用优化

## 概述

1. ES6涉及的一个性能领域的特殊要求：尾调用优化（ Tail Call Optimization， TCO）
    - 尾调用就是一个出现在另一个函数“结尾”处的函数调用
    ```javascript
    function bar(y) {
        return foo( y + 1 ); // 尾调用
    }
    function baz() {
        return 1 + bar( 40 ); // 非尾调用
    }
    ```
    - 这意味着 bar(..) 基本上已经完成了，那么在调用 foo(..) 时，它就不需要创建一个新的栈帧，而是可以重用已有的 bar(..) 的栈帧。这样不仅速度更快，也更节省内存
    
1. ES6要求引擎必须实现TCO，因为一些程序，无TCO则无法实现

1. 尾递归的本质实际上就是将方法需要的上下文通过方法的参数传递进下一次调用之中，以达到去除上层依赖

## 为何提倡使用尾调用

1. 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame）

2. 此调用帧，只有在函数执行完毕，才会被 js 机制内存回收

3. 如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）

4. 如下代码

   ```javascript
   function f() {
       let m = 1;
       let n = 2;
       return g(m + n);
   }
   f();
   
   // 等同于
   function f() {
       return g(3);
   }
   f();
   
   // 等同于
   g(3);
   ```

   - f函数不是尾调用，函数f需要保存m和n的值、g的调用位置等信息
   - 由于f是尾调用，调用`g`之后，函数`f`就结束了，所以执行到最后一步，完全可以删除`f(x)`的调用帧，只保留`g(3)`的调用帧。


## 尾递归

1. 如果尾调用自身，就称为尾递归

2. 通用斐波那契数列

  ```javascript
  function foo(n){
      if(n <=1){
          return 1;
      }
      return foo(n-1)+ foo(n-2)
  }
  ```

  - n=100就会造成栈溢出

3. 尾递归斐波那契数列

  ```javascript
  function foo(n,ac1 = 1, ac2 = 1){
      if(n <=1){
          return ac2;
      }
      return foo(n-1, ac2, ac1+ac2)
  }
  ```

  - 利用参数来存储之前的值

# 内存管理

## 什么是内存

1. 内存可以看作是一个巨大的bits数组
2. 但我们并不擅长用bits思考问题，故使用byte来思考（1byte = 8bits）
3. 很多东西存储在内存中：如程序运行的全部变量与数据、程序代码（包括操作系统的）

## 内存动态分配

1. 如`const arr = readInput()`，arr数组大小需要根据用户输入才知道，故在编译阶段并不知道要给arr分配多少内存合适

2. 所以不能给arr在栈上分配，故需要在堆上分配

3. 两者的区别

	| 静态分配               | 动态分配           |
	| ---------------------- | ------------------ |
	| 编译时知道内存使用大小 | 不知道             |
	| 分配在栈上             | 分配在堆上         |
	| FILO结构               | 没有特殊的分配顺序 |

​	

## 垃圾回收机制

### 为何需要这样的机制

1. JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储这个实体。当这些值不再需要时，需要释放内存，否则，Js会消耗完全部内存，造成系统崩溃。
2. 垃圾回收的方法：标记清除、计数引用。

### 标记清除

1. 最常见的垃圾回收方式
2. 会为进入环境和离开环境的变量打上标记
3. 可以使用任何方式来标记变量，如通过翻转某个特殊位来记录何时进入环境，何时离开环境
4. 垃圾回收器会定期清除标记为离开环境的变量，以释放内存

### 引用计数（不常见）

1. 跟踪记录每个值被引用的次数

2. 何为引用：

	- 如一个对象可以访问另一个对象（无论是隐式还是显示）
	- 如js对象隐式引用他的原型，显示引用它的属性值

3. 当声明一个变量，并用一个引用类型值a赋值时，会将a引用次数标记为1，如变量更换了引用值，则a的引用次数标记减1，为0

4. 垃圾回收器会定时回收标记为0的

5. 此方式会导致内存泄漏

	```javascript
	function problem() {
	    var objA = new Object();
	    var objB = new Object();
	    objA.someOtherObject = objB;
	    objB.anotherObject = objA;
	}
	```

	- objA与objB相互引用，会被标记为2，当两个对象离开作用域后，计数不为0
	- 垃圾回收器并不能回收这样的对象，故会造成内存泄露

6. Mark-sweep算法，解决上述循环引用的问题

	- 会先获取根对象，如window或global
	- 然后检查其孩子并进行标记
	- 回收不在根上的对象
	- 对于循环引用的对象，由于未与根对象相关，故会被回收

### 注意

1. GC是不可以预测的，你并不知道它何时执行

# V8引擎

## 内存管理

### 内存限制

1. Node中通过js使用内存时就会发现只能使用部分内存(64位系统下约为1.4 GB，32位系统下约为0.7 GB)
2. 因此，node无法直接操作大内存对象，比如无法将一个2 GB的文件读入内存中进行字符串分析处理，即使物理内存有32 GB
3. 主要原因是node是基于v8构建的，Node使用的js对象基本上都是通过V8自己的方式来进行分配和管理的
4. 但Node中的内存使用并非都是通过V8进行分配的，那些不是通过V8分配的内存称为堆外内存（如Buffer）

### 对象分配

1. 在V8中，所有的JavaScript对象都是通过堆来进行分配的
2. 为何v8会限制内存的使用
   - 表层原因：V8最初为浏览器而设计，不太会遇到大量内存使用的场景
   - 深层原因：v8垃圾回收机制，以1.5G内存为例，做一次非增量式的垃圾回收甚至要1秒以上，垃圾回收会暂停js线程，会大大影响应用性能
3. 对于node应用
   - `process.memoryUsage()`：查看当前使用的内存情况
   - 也可以调整内存限制

## 垃圾回收机制

### 回收算法

#### 概述

1. 主要基于分代式垃圾回收机制
2. 在实际应用中，上述介绍的通用方法并不能胜任全部场景
3. 现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。

#### 内存分代

1. 在V8中，主要将内存分为新生代和老生代两代

   ![image-20200203121915207](13-错误处理与性能.assets/image-20200203121915207.png)

   - 新生代中的对象：存活时间较短的对象
   - 老生代中的对象：存活时间较长或常驻内存的对象

2. node中通过--max-old-space-size与--max-new-space-size，可以分别调整两个空间的大小

3. 但这个设置需要在node启动前进行，意味着node并不能根据使用情况自动扩充

#### Scavenge算法

1. 在分代的基础上，主要使用此算法的一个实现Cheney算法
2. 这个算法的思想
   - 将内存空间分为两个部分，分别称为FROM（使用状态）和TO（闲置状态）
   - 进行回收时，将FROM内的激活状态是对象复制到TO，
   - 然后清空FROM，两个空间角色进行交换
3. 主要缺点：只能使用堆内存中的一半，空间利用率低
4. 主要优点：非常适合新生代的内存空间，因为新生代中对象的生命周期较短，存活的对象也只占少数
5. 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象，移动到老生代，采用新的算法进行管理，这个过程称之为：晋升
6. 晋升的条件
   - 对象是否经历过Scavenge回收，如果回收过，则晋升
   - To空间的内存占用比：如一个对象复制到To，To空间占用超过25%，则将对象晋升，主要是因为之后会切换FROM和TO的空间职能，如果TO空间占用太多，会影响后续的内存分配

#### Mark-Sweep

1. 主要是处理老生代空间的算法
2. Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。 活对象在新生代中只占较小部分，死对象在老生代中只占较小部分
3. Mark-Sweep（标记清除）
   - 标记阶段：遍历全部对象，标记活着的对象
   - 清除阶段：直接清除未标记的
4. 主要问题是：清除后，内存空间会出现不连续的状态，这会为后续的内存分配造成困难
5. 为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来

#### Mark-Compact

1. 可以理解为标记整理的意思
2. 主要思路是：在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存
3. 由于此算法会移动对象，故速度会最慢的
4. 因此，为了性能，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。

#### Incremental Marking

1. 为了避免出现js应用逻辑与垃圾回收器看到的不一致的情况，3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑
2. 对于新生代存活对象少，全停顿影响不大，但对于老生代存活对象多，进行全标记、整理会占用大量时间
3. 故V8采用增量方式，将标记全部内容拆分为多步，每步标记部分、整理部分，然后让js应用执行一会，再进行处理

### 查看垃圾回收日志

1. node启动时添加`--trace_gc`参数
2. `node --prof test01.js`
   - 可以得到V8执行时的性能分析数据
   - 会在目录下得到一个v8.log日志文件，但此文件无可读性
3. v8提供了linux-tick-processor工具用于统计日志信息（deps/v8/tools目录下）
   - `linux-tick-processor v8.log` 可以获得统计信息
   - 可以看到垃圾回收占比

## 内存泄漏

1. 尽管内存泄漏的情况不尽相同，但实质是：应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象

### 慎将内存当做缓存

1. 在Node中，缓存并非物美价廉，一般被作为缓存，会被存储在老生代中，存储的越多，会导致垃圾回收扫描的消耗越多
2. 另一个方面，一般习惯使用对象来缓存东西，但严格意义讲，键值对的对象与缓存是有区别的，缓存是有严格过期策略的
3. 进程是无法共用缓存的，可能会导致缓存不可避免地有重复，对物理内存是一种浪费，故要使用大量缓存最好还是采用进程外缓存-redis等

### 关注队列状态

1. 如队列消费速度低于生产速度， 将会形成堆积，会产生内存泄漏
2. 表层的解决办法是：换用消费速度更快的方式，但还是无法应对激增
3. 深层的结晶办法是：
   - 监控队列长度，一旦堆积，则进行报警
   - 增加调用超时设置，为消费速度设置一个下限
   - 阻塞设置：当队列满了，则禁止再添加内容

## 大内存应用

1. 由于V8的内存限制，我们无法通过`fs.readFile()`和`fs.writeFile()`直接进行大文件的操作
2. 改用`fs.createReadStream()`和`fs.createWriteStream()`方法通过流的方式实现对大文件的操作