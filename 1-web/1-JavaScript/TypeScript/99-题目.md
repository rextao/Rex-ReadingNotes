TypeScript面试题

1. 实现一个 zip 函数，对两个数组的元素按顺序两两合并，比如输入 [1,2,3], [4,5,6] 时，返回 [[1,4], [2,5],[3,6]]，并实现类型推导

   ```javascript
   function zip(target, source) {
     if (!target.length || !source.length) return [];
   
     const [one, ...rest1] = target;
     const [other, ...rest2] = source;
   
     return [[one, other], ...zip(rest1, rest2)];
   }
   ```

   ```typescript
   // 实现 输入 [1,2,3], [4,5,6] 时，返回 [[1,4], [2,5],[3,6]]的类型
   type Zip<T, S> = 
       T extends [infer A, ...infer B] 
           ?  
               S extends [infer SA, ...infer SB] 
                   ? [[A,SA],...Zip<B,SB>]
                   : []        
           :[]
   // type AAA = Zip<[1,2,3], [4,5,6]> ===> type AAA = [[1, 4], [2, 5], [3, 6]]
   ```

   ```typescript
   // 实现类型函数
   function zip<Target extends  unknown[], Source extends  unknown[]>(target: Target, source:Source): Zip<Target,Source>{
     if (!target.length || !source.length) return [];
   
     const [one, ...rest1] = target;
     const [other, ...rest2] = source;
   
     return [[one, other], ...zip(rest1, rest2)];
   }
   // 最后一行会报：Type '[unknown[]]' is not assignable to type 'Zip<Target, Source>'，利用重载解决
   function zip<Target extends  unknown[], Source extends  unknown[]>(target: Target, source:Source): Zip<Target,Source>;
   function zip(target: unknown[], source:unknown[]){}
   // 得到结果：const A = zip([1,2,3] ,[4,5,6])  A的类型为：const A: []
   ```

   ```typescript
   // 匹配的函数类型是对的，只不过推导出的不是字面量类型，因此，可以加上 as const
   const A = zip([1,2,3] as const,[4,5,6] as const)
   // 由于 as const 会生成readOnly 的类型，故需要给zip的传入参数设置readOnly
   function zip<Target extends readonly unknown[], Source extends  readonly unknown[]>(target: Target, source:Source): Zip<Target,Source>;
   // 但会导致内部的推导都需要readOnly，一个个加太麻烦了，可以做一个删除readOnly的映射类型
   type Mu<Obj> = {
       -readonly [key in keyof Obj] : Obj[key];
   }
   ```

   ```typescript
   // 得到最终结果
   function zip<Target extends readonly unknown[], Source extends readonly unknown[]>(target: Target, source:Source): Zip<Mu<Target>,Mu<Source>>;*
   ```

   
