# 强制类型转换
## 值类型转换
1. js强制类型转换总返回标量基本类型，不会返回对象或函数
2. 强制类型转换严格意义上说与装箱拆箱不是一回事

## 抽象值操作
### ToString

1. 规则

    - null 转换为 "null"，undefined 转换为 "undefined"， true转换为 "true"
    - 数字使用通用规则，极大或极小用指数
    - 普通对象，返回内部属性 [[Class]] 的值
    - 数组，将所有单元字符串化以后再用 "," 连接
    - 可以自己定义toString方法

1. JSON 字符串化

    - 效果与toString基本相同，但结果总是字符串
    - 安全的 JSON 值（ JSON-safe）都可以使用 JSON.stringify(..) 字符串化
    - 非安全的JSON
        - undefined、 function、 symbol包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON结构标准
        - 在使用JSON.stringify遇到非安全JSON会忽略，数组会换为null，保证数组位置不变
    - 处理非安全JSON
        - 定义toJSON方法，返回安全JSON
        - 返回一个能够被字符串化的安全的 JSON 值”，而不是“返回一个 JSON 字符串”。


### ToNumber

1. 会利用 valueOf() 和 toString() 对值进行转换
2. Object.create(null) 创建的对象 [[Prototype]] 属性为 null，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换

### ToBoolean

1. 假值
    - undefined，null，false，-0，+0，0，NaN，“”
1. 假值外的都是真值（如[]，unction(){}{}）
    - 强制类型转换时，这些值会转换为真值

## 对象转基本类型

1. 对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的

2. 也可以重写 `Symbol.toPrimitive` ，该方法在转基本类型时调用优先级最高。

	- `Symbol.toPrimitive`：一个对象可被转换为原始值。该函数由字符串参数 hint 调用，目的是指定原始值转换结果的首选类型。 hint 参数可以是`"number"`、`"string" `和 `"default"` 中的一种。

3. ```javascript
	// 没有 Symbol.toPrimitive 属性的对象
	var obj1 = {};
	console.log(+obj1);     // NaN
	console.log(`${obj1}`); // "[object Object]"
	console.log(obj1 + ""); // "[object Object]"
	
	// valueOf,toString()可以重写，以控制obj返回值
	var obj2 = {
	    valueOf(){
	        return 1;
	    }
	}
	console.log(+obj2);     // 1
	console.log(`${obj2}`); // "[object Object]"
	console.log(obj2 + ""); // "1"
	
	// [Symbol.toPrimitive]优先级更高
	var obj3 = {
	    valueOf(){
	        return 1;
	    },
	    [Symbol.toPrimitive]() {
	     	return 333;   
	    }   
	}
	console.log(+obj3);     // 333
	console.log(`${obj3}`); // 333
	console.log(obj3 + ""); // 333
	
	
	// 拥有 Symbol.toPrimitive 属性的对象
	var obj4 = {
	  [Symbol.toPrimitive](hint) {
	    if (hint == "number") {
	      return 10;
	    }
	    if (hint == "string") {
	      return "hello";
	    }
	    return true;
	  }
	};
	console.log(+obj4);     // 10      -- hint is "number"
	console.log(`${obj4}`); // "hello" -- hint is "string"
	console.log(obj4 + ""); // "true"  -- hint is "default"
	```

## 显式强制类型转换
### 字符串和数字之间的显式转换
1. 通过 String(..) 和 Number(..) 这两个内建函数
    - 前面没有new，并不创建封装对象
1. 字符串转数字
    - 一元运算符+
1. 数字转字符串
    - toString
        - js引擎会将数字包装后，包装对象调用toString方法
1. 日期显式转换为数字
    - 一元运算符 + 可以将date转换为Unix时间戳
        - 不建议使用
    - new Date().getTime() == +new Date() == Date.now()；
1. ~ 运算符
    - 字位运算符只适用于 32 位整数
    - ~会强制操作数使用32位格式，然后字位反转
    - ~x 大致等同于 -(x+1)
        - 因为只有-0为假值，故可用~来判断if
        - ```if(~a.indexof("o")) == if (a.indexof("o")!==-1)```
1. 字位截除
    - ~~ 用来截取数字值的小数部分
    - 第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值
    - ~~-49.6; // -49
    - 可以理解为是：Math.floor()

### 解析数字字符串
1. 解析和转换两者之间有明显的差别
    - 解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止
    - 转换不允许出现非数字字符，否则会失败并返回 NaN。
1. parseInt()：字符串解析为整数
    - 忽略前置空格，查询第一个非空字符
    - 如第一个非空字符，不是数值或负号，返回NaN；空字符串返回NaN，Number("")返回0
    - 从第二个字符直到解析完，或遇到一个非数字字符
        - 如22.2，解析数字为22，因为小数点不是有效数字字符
    - 注意：
        - ES3和ES5对八进制的解析是不同的，070，ES3认为是56（十进制），ES5认为前置0无效，解析为70
        - ```parseInt("111","16")：``第二个参数指定进制数，解决上述问题
1. parseInt的坑
    ```javascript
    console.log(parseInt(0.000008));    //0,来自0.000008
    console.log(parseInt(0.0000008));   //8,来自8e-7
    console.log(parseInt(false,16));    //250，fa来自false
    console.log(parseInt(parseInt,16)); // 15,"f"来自function(){}
    console.log(parseInt(1/0,19));      // 18，来自Infinity的I，19为基数，a表示10，I表示18
    ```
    - parseInt要求传入字符串，如不正确传入，会出现错误
1. parseFloat()：字符串解析为浮点类型
    - 字符串第一个小数点是有效的
    - 只解析十进制
    - 如解析的是一个整数，小数点后都是0，会返回整数

### 转换为布尔值
1. Boolean(..)（不带 new）是显式的 ToBoolean 强制类型转换
1. 最常用的方法是：！！
1. ``` a ? true : false;```涉及到了隐式强制类型转换，因为需要先将a转换为布尔值

### 转换为字符串
1. 方法一：
    - toString()方法
    - Null和undefined没有这个方法
    - 可以传入参数表示输出数值的进制数
    - ``` var num =10; num.toString(16);//"a"```直接10.toString()会报错
1. 方法二：
    - String()函数
    - 如值有toString()方法，调用
    - 如值为null，转换为"null"
    - 值为undefined，转换为"undefined"

## 隐式强制类型转换
### 字符串和数字之间
#### +号运算符

1. 能用于数字加法，也能用于字符串拼接
2. 只要有一边为字符串，则是字符串拼接
3. `'a' + + 'b' `=>aNaN，'b'会被转换为NaN，然后和a进行字符串拼接

#### .a + ""（隐式）和 String(a)（显式）的差别

1. a + "" 会对 a 调用 valueOf() 方法，再调用ToString 将返回值转换为字符串
2. String(a) 则是直接调用 ToString()

#### -，*，/号运算符

1. 会强制转换为数字
2. 不会形成字符串拼接

### 布尔值到数字
1. a && !b && !c常用来判断true或false
1. 但如果20多个a，b联合判断，使用这种方式很冗余
1. ```sum += a[i];```
    - 通过隐式转换，将a[i]转换为数字，然后通过累加，判断结果是0还是>1来判断true或false
    - 类似于```sum += Number(!!a[i])```

### 转换为布尔值
1. if (..)
1. for ( .. ; .. ; .. )第二个
1. while (..) 和 do..while(..)
1.  ? : 中的条件判断表达式
1. ||、&&、左边的操作数

### || 和 &&
1. 返回值是两个操作数中的一个（且仅一个），并不是布尔值
1. || 首先会对第一个操作数，如能强转为true，返回第一个操作数
1. &&首先会对第一个操作数，如能强转为true，返回第二个操作数
```javascript
var a = 42;
a && foo();
```
    - 相当于if(a){foo()},压缩工具中常使用

### 符号的强制类型转换
1. ES6 允许从符号到字符串的显式强制类型转换
    - String( Symbol("cool") ); // "Symbol(cool)"
1. 隐式强制类型转换会产生错误
    - Symbol("cool")+""//TypeError
1. 鉴于符号类型的特殊用法，一般不会对其进行强制类型转换

## 宽松相等和严格相等
1. ==允许在相等比较中进行强制类型转换，而===不允许
1. 抽象相等
    - 其他类型和布尔类型之间的相等比较

    	```javascript
    	var a = "42";
    	var b = true;
    	var c = false;
    	console.log(a == b);    //false
    	console.log(a == c);    //false
    	console.log(b == "1");  //true
    	console.log(c == "0");  //true
    	```

    - a虽然是真值，但强制转换不是true，而是转换为1（这是根据规范来的）
    - == 两边的布尔值会被强制类型转换为数字。

    - 最好避免使用==false或==true

    - null 和 undefined 之间的相等比较
        - 在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他值都不与这两个值相等（包括假值）。
1. 比较少见的情况
    - 返回其他数字

    	```javascript
    	Number.prototype.valueOf = function () {
    	    return 3;
    	}
    	console.log(new Number(3) == 3); // true
    	```

    	- 因为==会用到valueOf，所以重写valueof时候一定要特别注意
    - 安全运用隐式强制类型转换
        - 如果两边的值中有 true 或者 false，千万不要使用 ==
        - 如果两边的值中有 []、 "" 或者 0，尽量不要使用 ==
        - 对于一些奇葩值的==结果，可参见http://dorey.github.io/JavaScript-Equality-Table/
        - 最好不要对奇葩值进行==

1. 极端情况
  - []与{}
    - [] + {}; // "[object Object]
        - [] 转换为""，{}被当做空对象，故返回[object Object]
    - {} + []; // 0
        - {}作为独立代码块，不执行任何操作，+[]强制类型转换为0

## 抽象关系比较（>,<,>=,<=）
1. 比较双方都是字符串，则按字母顺序来进行比较













