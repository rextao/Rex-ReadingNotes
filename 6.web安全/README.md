# XSS



## 概述

1. Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。
2. 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。
3. 本质是：恶意代码未经过滤。

## xss分类

| 类型       | 存储区                  | 插入点          |
| ---------- | ----------------------- | --------------- |
| 存储型 XSS | 后端数据库              | HTML            |
| 反射型 XSS | URL                     | HTML            |
| DOM 型 XSS | 后端数据库/前端存储/URL | 前端 JavaScript |

1. 存储型xss
	- 黑客将xss代码通过用户评论等提交
	- 网站将xss代码存储到数据库
	- 其他人访问评论列表时，xss代码被执行
2. 反射型xss
	- 假设网站一个功能是将用户输入的参数，输出到页面上
	- 故黑客可以将一段`<script></script>`代码作为参数传入进行攻击
3. DOM型xss
	- 如有个功能是，点click，会在当前页面插入一个超链接，其地址为文本框的内容
	- 那么文本框如构造`' onclick=alert(/xss/) //` 会将原本的超链接，变为alert

## 举例

1. 如对用户不进行过滤，完全信任用户输入，如一个评论框，用户这样输入：![1557327281590](README.assets/1557327281590.png)
2. 这样无论是谁访问这个页面都会输出console这段内容

## 如何防御

1. 最佳的做法就是对数据进行严格的输出编码，使得攻击者提供的数据不再被浏览器认为是脚本而被误执行
2. 要堵住这个漏洞，关键不在于输入过滤，而在于输出过滤 

## 攻击预防

1. xss攻击有两大要素，一是：进行输入过滤，阻止攻击者提交恶意代码；二是：防止浏览器执行恶意代码

### 存储型和反射型攻击

#### 纯前端渲染

1. 预先加载html，html中不包含业务代码
2. 加载js，然后通过js请求业务数据
3. 由于会明确告诉浏览器，设置的内容是文本（`.innerText`），还是属性（`.setAttribute`），还是样式（`.style`）等等，浏览器不会轻易被欺骗
4. 但DOM型xss还需要避免

#### 转义HTML

1. 把 `& < > "` 这几个字符转义(`&amp; &lt; &gt; &quot; `)掉，确实能起到一定的 XSS 防护作用
2. 注意：不同上下文转义的规则不同，比如文本信息<>可能不需要转义，html需要转义

### DOM 型攻击

1. 主要原因是js代码不严谨，把不可信数据执行了

### 其他手段

1. 可以通过限制输入内容长度，增大xss攻击难度

# CSRF攻击

## 概述

1. CSRF（Cross Site Request Forgery），中文是跨站点请求伪造。
2. 黑客并不能拿到 cookie，也看不到 cookie 的内容。由于浏览器同源策略的限制，黑客也无法解析服务器返回结果。
3. 攻击者通过盗用了你的身份，以你的名义发送恶意请求，主要利用的是网站对用户网页浏览器的信任

## 攻击原理

1. a登录了c网站，a处存有c网站的cookie
2. c网站一个转账请求使用的是get请求，即通过`http://www.mybank.com/Transfer.php?toBankId=11&money=1000`就可以转账
3. 攻击者可以在论坛、邮箱中构造一个链接诱导用户去点击，或者直接在论坛上传外链图片（用户一进入，就会默认加载这个图片，即直接发起转账请求）

## 防御手段

1. 防御关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中

### 尽量使用POST，限制GET

1. GET接口太容易被拿来做CSRF攻击，只要构造一个img标签，就可以进行攻击
2. 但对于post请求，攻击者可以构造一个form表单

### 加验证码

1. 验证码能很好遏制CSRF攻击，但出于用户体验的考虑，不能将所有操作都加上验证码

### Referer Check

1. 当浏览器向web服务器发出请求的时，一般会带上Referer请求头，告诉服务器用户从哪个页面连接过来的
2. js中通过`document.referrer`获取referrer
3. 对于CSRF攻击，黑客需要在自己网站构造请求，referer值肯定不同
4. 但referer值由浏览器提供，不能保证浏览器没有安全漏洞，而且这种方式是将安全性都依赖于第三方（即浏览器）来保障

## Anti CSRF Token

1. 服务端在收到路由请求时，生成一个随机数token，在渲染请求页面时把随机数埋入页面（一般埋入 form 表单内，<input type="hidden" name="csrf_token" value="xxxx">）
2. 将token保存在session中
3. 当用户发送 GET 或者 POST 请求时带上csrf_token参数
4. 服务器将用户发来的token与session中的token进行对比。
5. 由于黑客无法获取随机的token，故可以防止黑客进行csrf攻击

# HTTPS降级攻击

1. 唯一解决问题的方法是禁用 SSL 3.0 加密协议

# 警惕iframe带来的风险

## 概述

1. 前端页面需要用到第三方提供的页面组件，通常会以iframe的方式引入。
2. 如果iframe中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件等等，这问题可就大了 

## 如何防御

1. 在HTML5中，iframe有了一个叫做sandbox的安全属性 
2. 可以对iframe进行细粒度的操作，比如不准提交表单、不准弹窗、不准执行脚本等等 





# SQL注入

1. 之所以会发生SQL注入，主要因为代码中存在拼接SQL语句的情况 