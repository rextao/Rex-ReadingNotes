# 

# TCP

1. 因特网两大核心协议以及作用？
   - ip：路由选择和寻址
   - TCP：不可靠的传输信道之上提供可靠的抽象层
2. 三次握手？
   - 客户端发syn，进入SYN_SEND状态
   - 服务器回复ack+syn，进入SYN_RECV状态
   - 客户端发ack，两者都进入ESTABLISHED
3. 四次挥手
   - 客户端发FIN，进入FIN_WAIT_1
   - 服务器回，ACK，进入CLOSE_WAIT
   - 服务器发，FIN，进入LAST_ACK
   - 客户端发ACK，进入TIME_WAIT，服务器进入CLOSED
4. 为何4次挥手
   - 服务器收到FIN后，可能数据还未传输完
   - 故先回ack，等数据传输完后回复FIN
5. 拥塞崩溃？
   - 路由接收信息的速率超过了自身处理速度，会出现延迟
   - 路由会将数据进行排队等待
   - 但等待数据超量时，会丢弃接收数据
   - 由于TCP超时重连机制，会重新发送数据，导致死循环
   - 造成整个网络的瘫痪
6. 流量控制？
   - 相互交流自己的数据接收能力，避免发送过多数据
   - TCP连接的每一方需要通报自己的数据接收窗口
7. 慢启动主要目的，主要缺点？？
   - 连接建立之初，并不知道带宽多少，故先发小的数据包，然后逐渐增大发送量
   - 对传输小文件很不利
8. TCP窗口机制？
   - 固定窗口：第一次发送窗口为1，然后发2，然后发3，依次增加
   - 滑动窗口：第一次发3，但只能接收2，再更改发送窗口为2
9. 什么是队首阻塞？
   - TCP传输中如某个分组丢失，需要在接收端等等分组重发
   - 对于应用层，必须等全部分组到达后才能访问数据
10. TCP如何保证传输可靠性
    - 三次握手，四次挥手保证可靠连接
    - 流量控制，拥塞控制，超时重传等机制

# UDP

1. UDP与TCP的区别？
   - TCP使用分组，UDP使用数据报
   - webRTC是基于UDP是
   - UDP是不可靠传输协议
2. IP 网络地址转换器是什么？
   - 由于IPv4地址只有32位，为了解决地址要耗尽的问题
   - 利用ip地址转换器，ip可以在不同网络下进行重用

# TSL

1. SSL与TLS关系
   - SSL最早是网景公司为了保证网络交易安全而开发的
   - TLS建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本
   - TLS的主要目标是使SSL更安全
2. TLS握手
   - 由于TLS基于TCP，故需要先进行TCP三次握手
   - 客户端发送TLS版本等，服务器利用非对称加密，将公钥放在证书中给客户端
   - 客户端拿到证书后，验证ca，构造对称加密，用公钥加密后给服务器
   - 服务器私钥解密拿到对称密钥
   - 然后加密传输信息

# HTTP

1. 7层网络模型
   - 物理，数据链路，网络，传输，会话，表示，应用
2. 5层TCP/IP模型
   - 物理，数据链路，网络，传输，应用
3. HTTP1.x的主要特点
   - 持久化连接，避免后序TCP3次握手，慢启动，主要是在请求头设置Connection：keep-alive
   - HTTP管道：消除发送和响应的等待时间，但由于中间路由可能不支持，大多数浏览器禁用；主要是将FIFO队列移动到服务端
   - 使用多个TCP连接
4. http1.1时如何复用tcp连接
   - 利用持久化连接，即在发送http的请求头中设置Connection: keep-alive
   - 可以避免后序的TCP连接时的三次握手，消除后序的TCP慢启动的往返
5. HTTP2.0
   - 使用二进制分帧层，将1.x的纯文本转为更小的消息与帧
   - 一个TCP连接上承载多个数据流，每个数据流以消息发送，而消息由一个或多个帧组成，帧可以乱序发送，然后根据帧的首部的流标识符重新组装
   - 首部压缩，用首部表存储请求的键值对，如请求头一样则不再发送，避免传输冗余的首部
   - 多路复用：客户端不需要等第一个请求响应后再发送第二个请求
6. 常见状态码
   - 1xx，消息类
   - 2xx，成功；200（ok），204（成功但无资源返回）
   - 3xx，重定向；301（永久重定向 ），302（临时重定向，使用原有请求方法），303（临时重定向，用get），304（使用缓存），307（临时重定向，不指定方法）
   - 4xx，浏览器错误；400（语义有问题，无法被服务器理解）；401（未授权）；403（禁止访问）；404（资源未找到）
   - 5xx，服务器错误；500（服务器异常），503（服务器在维护）
7. http有什么请求类型
   - get，post
   - head（获取响应头）
   - put（向指定资源上传新内容）
   - delete（删除指定资源）
   - options，获取资源支持的http请求类型
8. get与post请求区别
   - 本质是，GET产生一个TCP数据包；POST产生两个TCP数据包。
   - post发送的数据更大（get有url长度限制） 
   - post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中） 
   - 缓存：get浏览器会默认缓存，post不会
   - 书签：get可收藏为书签，post不可以
9. 解决http无状态性
   - cookie与session
10. cookie属性选项
    - expires：cookie过期时间
    - domian和path，浏览器自动添加到请求头
    - secure，是否只有https请求可以发送
    - httpOnly：能否js访问cookie
11. 服务器设置cookie
    - set-cookie响应头，每个字段对应一个
12. 客户端cookie
    - document.cookie
13. 子cookie
    - 为了绕开浏览器对单个域名的cookie限制
14. cookie缺点
    - `Cookie`数量和长度的限制
    - 安全性
    - 有过期时间
    - 设计之初不是为了存储数据的
15. https主要为了解决
    - http被劫持问题