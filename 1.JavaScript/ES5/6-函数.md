# 函数
## 概述
1. 函数是设计用于执行特定任务的子程序。
1. 函数实际上是对象，每个函数是Function类型的实例，函数名实际是指向函数对象的指针
1. 函数是可调用对象
1. 函数总会返回一个值
    - 不指定返回值，函数无return语句，函数返回undefined
    - return后不带任何返回值，函数返回undefined
    - 位于return后的代码永远不会执行
1. 函数两种定义方式：函数声明与函数表达式

## 内部属性

### arguments对象

1. 函数参数在函数内部可理解为一个数组，函数体内用arguments对象来访问这个参数数组
2. arguments对象使用`Array.prototype.slice()`转化为数组
3. arguments与命名参数一同使用，对arguments[1]，会改变第二个参数值
4. arguments与命名参数值保持同步，但两者内存是独立的

### this

1. this引用的是函数的执行环境对象

### caller

1. caller：函数对象的属性，调用当前函数的函数的引用

## 属性和方法

### length

1. 函数希望接收的命名参数的个数，函数定义时的命名参数个数

### prototype

1. prototype是保存所有实例方法的真正所在
2. 属性是不可枚举的，无法用for-in发现

### call()

1. 在特定作用域上调用函数，实际是设置函数体内this对象的值
2. 两个参数：一个是运行函数作用域，另一个是参数数组

### apply()

1. 与apply主要区别是，第一个参数是运行函数作用域，其余参数是直接传递给函数的参数
2. 与call()主要区别：看给函数传递参数的方式
3. 与call()主要作用：扩充函数的运行作用域

### bind()

1. ES5定义的方法
2. 创建一个函数的实例，其this值会被绑定到传给bind()函数的值
3. 注意：bind函数返回的是一个函数，而apply和call为函数调用，因此需要`obj.bind(obj1)()类似于obj.call(obj1)`

### toString()

1. 返回函数的代码，不同浏览器可能存在差异

## 理解参数
1. ES函数不介意传入多少个参数，也不在乎传入的数据类型
1. ES的命名参数只是提供便利，但不是必须的
1. 没有传递的命名参数会被自动赋值为undefined
1. 由于ES中函数名本身是变量，所以函数也可作为值来使用，即可以像传递参数一样把一个函数传递给另一个函数



## 没有重载
1. 没有函数签名，真正意义的重载是不可能做到的
1. 将函数名理解为指针，有助于理解ES没有重载的概念
1. 但用arguments可以模拟

# 函数声明

## 概述

1. 函数声明：`function a (){}`
2. 特点：函数声明会提升，可以在声明前调用函数
3. 解析器会先读取函数声明，并使其在执行任何代码之前可用
4. 最好先声明函数再调用，而不是利用函数提升



# 函数表达式
## 概述
1. 函数表达式：`var a = function(){}`
2. 使用前必须先赋值
3. 函数表达式，必须等到解析器执行到它所在的代码行，才会被解析到

## 具名函数表达式

1. 具名的函数表达方便调试

2. 具名函数只是将一个名字附加在函数上，并不意味着可以它使用调用函数，如

	```javascript
	var addVariable = function addFunction(param1, param2) {
	    return param1 + param2 ;
	}
	var result = addFunction(num1, num2); 
	// ==> Uncaught ReferenceError: addFunction is not defined
	```

3. 但`addFunction`，可以在函数内部使用

	```javascript
	var addVariable = function addFunction(param1, param2) {
	    if(param1 === 0) {
	      param1 = addFunction(1,param2);
	    }
	    return param1 + param2 ;
	  };
	addVariable(0,2) // 5;
	```


## 递归
1. 递归使用函数名可能会出错
```javascript
function foo(num) {
    if(num <= 1){
        return 1;
    }else{
        return num* foo(num-1)
    }
}
console.log(foo(4)); //24
var bar = foo;
foo =null;
console.log(bar(4)); //Uncaught TypeError: foo is not a function
```

1. 使用arguments.callee
    - 指向正在执行的函数的指针，可以用来实现对函数的递归调用，虽然使用此方法能避免上述问题
    - 官方建议是：当一个函数必须调用自身的时候, 避免使用 arguments.callee(), 通过要么给函数表达式一个名字,要么使用一个函数声明
    - 严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误，可以使用命名函数表达式来达成相同的结果

# 立即执行函数（IIFE）

## 概述

1. 函数有一个功能是将一段代码包裹起来，避免污染当前作用域
2. 但函数依然存在问题：
	- 创建函数本身如foo，这个标识符污染了当前作用域
	- 需要foo()才能运行这段代码
3. 利用立即执行函数表达式可以解决上述函数问题
4. 立即执行函数（Immediately Invoked Function Expression，IIFE）
5. IIFE中声明的任何变量对外部都不可见

## IIFE的形式

1. 形式1：

	```javascript
	!function() {
	    alert("Hello from IIFE!");
	}();
	```

	- 如function出现在最前面，则会认为是函数声明
	- `!`是为了让js引擎认为这个function是一个函数表达式
	- 同样的一元操作符+、-、~、void都可以起到类似的效果
	- 但这样的方式不能获取IIFE的返回值

2. 形式2：

	```javascript
	// Variation 1
	(function() {
	    alert("I am an IIFE!");
	}());
	
	// Variation 2
	(function() {
	    alert("I am an IIFE, too!");
	})();
	```

	- 深入问题本质，两个版本略有不同，但从实际目的出发，选用哪种都可以

## 传入参数

1. 传入参数主要目是可以让参数在当前作用域查找，而不需向上查找

	```javascript
	var a = 123;
	// Variation 1
	(function(w) {
	    alert(w.a);
	    alert(window.a);//其实此处直接用window对象，也可以返回window.a的值
	}(window));
	
	// Variation 2
	(function(w) {
	    alert(w.a);
	})(window);
	```

2. 注意：

   - 声明以（funtion。。。开始，函数会被当作函数表达式而不是一个标准的函数声明来处理
	- function出现在声明第一个词则为函数声明，否则为函数表达式(上面第一个词为`(`左边括号)

## IIFE与闭包

1. 通过IIFE与闭包可以保存数据

  ```javascript
  var Sequence = (function sequenceIIFE() {
      // Private variable to store current counter value.
      var current = 0;    
      // Object that's returned from the IIFE.
      return {
          getCurrentValue: function() {
              return current;
          },        
          getNextValue: function() {
              current = current + 1;
              return current;
          }
      };
      
  }());
  
  console.log(Sequence.getNextValue()); // 1
  console.log(Sequence.getNextValue()); // 2
  console.log(Sequence.getCurrentValue()); // 2
  ```




# 提升
##　概述
1. js代码执行时并不是由代码编写顺序上到下一行一行执行的
1. 变量和函数在内的所有声明都会在任何代码执行前首先被处理
1. 只有声明会被提升，赋值或其他运算逻辑留在原地
1. 每个作用域都会对函数进行提升
1. 多次声明同一变量，后面声明的变量会视而不见，但会执行后面声明中的变量初始化

## 函数声明会提升，函数表达式不会
1. 注意1：

	```javascript
	foo(); // 不是 ReferenceError, 而是 TypeError!
	var foo = function bar() {
		// ...
	};
	```

2. 声明提升后会变为

	```javascript
	var foo;
	foo(); // 不是 ReferenceError, 而是 TypeError!
	foo = function bar() {
		// ...
	};
	```

	- 故foo调用时，foo还未赋值，是undefined，无法函数调用

3. 具名函数表达式，名称标识符在赋值之前也无法在所在的作用域中使用

	```javascript
	foo(); // TypeError，有声明，未赋值
	bar(); // ReferenceError，未声明
	var foo = function bar() {
	    // ...
	};
	```

## 函数优先
1. 函数与变量声明都会被提升，函数首先被提升

	```javascript
	foo(); // 1
	var foo;
	function foo() {
		console.log( 1 );
	}
	foo = function() {
		console.log( 2 );
	};
	```

	- 函数首先提升，提升完后，变量提升，这时候发现有个foo函数声明，会忽略变量声明
	- 但如何后面还有函数声明，会覆盖先前的函数声明

2. 一个普通块内部的函数声明通常会被提升到所在作用域的顶部

	```javascript
	foo(); // "b"
	var a = true;
	if (a) {
	 	function foo() { console.log("a"); }
	}
	else {
	 	function foo() { console.log("b"); }
	}
	```

	- 为避免js之后版本变化，不要在块内部声明函数



# 纯函数

## 概述

1. 纯函数是函数式编程的基础，只有纯函数是给相同的输入，总会产生相同的输出
2. 常见的主要用途：
   - 将输入值与输出值进行映射
   - 处理一些列过程
   - 与系统的其他部分进行交流
3. 理解纯函数的目的，并不是也不可能所有函数都是纯函数，主要是为了分离两个过程，使程序更可读、可测试，最小化不稳定部分的代码

## 主要特征

1. 函数使用`arguments`与局部变量计算结果，故给定相同输入会得到相同的结果
2. 没有副作用（纯函数独立于外部状态）

## 副作用

1. 函数内部改变了函数外面某些值的状态，称为函数副作用

   ```javascript
   const joe = {
     firstName: 'Joe',
     lastName: 'Schmoe'
   }
   function impureUpdate () {
     joe.firstName = 'rex'
   }
   joe.firstName // 'Joe'
   unsafeUpdate() // changes `joe`'s `firstName` property
   joe.firstName // 'rex'
   ```

2. 副作用包括（但不限于）：

   - 改变文件系统
   - 数据库插入记录
   - http请求
   - 获取用户输入
   - 查询DOM
   - 访问系统状态

3. 因此，可以理解为纯函数是没有副作用的函数

## 纯函数的优势

### 可预测性

1. 纯函数给定相同输入，会得到相同结果，如下则不是一个纯函数

   ```javascript
   function hello(name){
       return `${name} say,time is ${new Date()}`
   }
   console.log(hello('rex'));
   console.log(hello('rex'));
   ```

   - 执行结果会因为时间的不同而不同
   - 由于new Date显示到秒级别，直接运行上述代码，结果会一致

### 易测试性

1. 由于可预测性，顾可以根据纯函数预测到应该得到结果

### 并行调用

1. 因为纯函数只是依赖于输入且并不改变外部状态，顾并行（几个函数同时计算）计算也不会出现竞争的情况

### 引用透明性

1. 函数调用可以被其返回值所代替，且并不会改变程序总体的运行效果

## 写纯函数时应注意

1. 不要更改全局状态
2. I/O、读写文件会有副作用，不允许在纯函数中；同样console到命令行一样具有副作用
3. AJAX，网络请求因为可能获得数据或发生错误，因此不允许在纯函数中使用
4. 一般通用规则是：处理数据时使用纯函数，操作结果时使用非纯函数

## 将非纯函数转纯函数

1. 这两种方式都类似于“欺诈”行为，即只是一种转换，将非纯函数转为纯函数
2. 但并不是消除了非纯函数的行为

### 依赖注入

1. 假设获取DOM，是非纯函数，因为引用了外部的document

	```javascript
	function getUserNameFromDOM() {
	    return document.querySelector('#username').value;
	}
	```

2. 依赖注入说白了，其实是将影响纯函数的部分作为参数传入，即

	```javascript
	function getUserNameFromDOM($) {
	    return $('#username').value;
	}
	const qs = document.querySelector.bind(document);
	getUserNameFromDOM(qs);
	```

3. 这样有什么好处呢，方便测试，即如果没有浏览器环境，可以将`$ =() => ({value: 'mhatter'}) `传入到getUserNameFromDom看是否能获得正确结果，但浏览器环境下的测试是必须的

4. 依赖注入主要的问题是，当很多参数时，会造成混乱

## Immutability

### 概述

1. immutable值是一旦创建就不能改变了，js中私有变量如numers，strings，booleans都是；而objects和arrays则不是了

2. 不可变性（immutable）是保证原始定义值不变

3. 如`Array.prototype.push` 会改变原定义数组的值，即并不会返回一个新数组；`Array.prototype.concat`会返回新数组，故前者变异了原始值，后者并没有

4. 不变性的理解：对于数组和对象，是指向内存，为了不变性，需要重新创建个对象再进行更改，而不是直接更改原对象


# 高阶函数

## 概述

1. 高阶函数是将函数作为参数接收或将函数作为输出返回的函数。
2. 如`Array.prototype.map`, `Array.prototype.filter` and `Array.prototype.reduce` 就是内置的一些高阶函数