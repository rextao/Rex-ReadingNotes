# http劫持

## 概述

1. 大多数情况是运营商HTTP劫持，在正常数据流增加一些弹出、宣传性广告或直接显示某网站的内容

##  被嵌套在iframe里

1. 如自己的页面被http劫持，运营商为了避免广告对原网站代码产生影响，通常将原网站放在iframe里
2. 可以通过判断`window.self === window.top`
3. 对于非同源域名，iframe子页面无法通过parent.location或top.location拿到页面地址，但是可以设置父级转跳，故如self与top不相同，可以控制父级进行转跳
4. 问题：可能重定向父级也会被http第二次劫持
   - 由于运营商劫持可能是有迹可循的，如常规手段是在url后增加一个参数`iframe_hijack_redirected=1`表示已经劫持过
   - 可以改写我们的url使其看起来好像是被劫持过的
5. 还需要建立上报系统，即对于被嵌套的情况，进行记录，逐步完善防护手段

## 白名单

1. 由于某些运营需要，可能需要将自己页面嵌入iframe在其他网站进行推广，需要判断在白名单里的网站不进行父级转跳
2. 需要在子iframe使用`document.referrer`拿到跨域 iframe 父页面的URL

## 更好的方式是https

1. http+ssl

# DNS劫持

## 概述

1. 主要是通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果
2. 使得本应访问a的ip，结果被重定向到b的ip

# XSS



## 概述

1. Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。
2. 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。
3. 本质是：恶意代码未经过滤。关键在于“脚本”

## xss分类

| 类型       | 存储区                  | 插入点          |
| ---------- | ----------------------- | --------------- |
| 存储型 XSS | 后端数据库              | HTML            |
| 反射型 XSS | URL                     | HTML            |
| DOM 型 XSS | 后端数据库/前端存储/URL | 前端 JavaScript |

1. 存储型xss
	- 黑客将xss代码通过用户评论等提交
	- 网站将xss代码存储到数据库
	- 其他人访问评论列表时，xss代码被执行
2. 反射型xss
	- 假设网站一个功能是将用户输入的参数，输出到页面上
	- 故黑客可以将一段`<script></script>`代码作为参数传入进行攻击
3. DOM型xss
	- 如有个功能是，点click，会在当前页面插入一个超链接，其地址为文本框的内容
	- 那么文本框如构造`' onclick=alert(/xss/) //` 会将原本的超链接，变为alert

## 举例

1. 如对用户不进行过滤，完全信任用户输入，如一个评论框，用户这样输入：![1557327281590](README.assets/1557327281590.png)
2. 这样无论是谁访问这个页面都会输出console这段内容

## 如何防御

### 转义HTML

1. 最佳的做法就是对数据进行严格的输出编码，使得攻击者提供的数据不再被浏览器认为是脚本而被误执行
2. 要堵住这个漏洞，关键不在于输入过滤，而在于输出过滤 
3. 把 `& < > "` 这几个字符转义(`&amp; &lt; &gt; &quot; `)掉，确实能起到一定的 XSS 防护作用
4. 注意：不同上下文转义的规则不同，比如文本信息<>可能不需要转义，html需要转义

### 纯前端渲染

1. 预先加载html，html中不包含业务代码
2. 加载js，然后通过js请求业务数据
3. 由于会明确告诉浏览器，设置的内容是文本（`.innerText`），还是属性（`.setAttribute`），还是样式（`.style`）等等，浏览器不会轻易被欺骗
4. 但DOM型xss还需要避免

### MutationObserver

1. 是能够监测到页面 DOM 树的变换，并作出反应，并不是发现一个元素就立即回调，而是将一个时间片段里出现的所有元素，一起传过来
2. 监听是否有脚本插入到html中，如发现恶意脚本则`removeChild()`掉

### CSP

1. 内容安全策略(csp)：主要目标是减少XSS 攻击
2. 主要是通过指定有效域，即浏览器认可的可执行脚本的有效来源，减少XSS攻击
3. 配置csp需要添加响应头`Content-Security-Policy`头，或用meta配置`<meta http-equiv="Content-Security-Policy" content="default-src 'self';">`
4. 想要所有内容均来自站点的同一个源：`Content-Security-Policy: default-src 'self'`

# CSRF攻击

## 概述

1. CSRF（Cross Site Request Forgery），中文是跨站点请求伪造。
2. 黑客并不能拿到 cookie，也看不到 cookie 的内容。由于浏览器同源策略的限制，黑客也无法解析服务器返回结果。
3. 攻击者通过盗用了你的身份，以你的名义发送恶意请求，主要利用的是网站对用户网页浏览器的信任

## 攻击原理

1. a登录了c网站（不登出），a处存有c网站的cookie
2. c网站一个转账请求使用的是get请求，即通过`http://www.mybank.com/Transfer.php?toBankId=11&money=1000`就可以转账
3. 攻击者可以在论坛、邮箱中构造一个链接诱导用户去点击，或者直接在论坛上传外链图片（用户一进入，就会默认加载这个图片，即直接发起转账请求）

## 防御手段

1. 防御关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中

### 尽量使用POST，限制GET

1. GET接口太容易被拿来做CSRF攻击，只要构造一个img标签，就可以进行攻击
2. 但对于post请求，攻击者可以构造一个form表单

### 加验证码

1. 验证码能很好遏制CSRF攻击，但出于用户体验的考虑，不能将所有操作都加上验证码

### Referer Check

1. 当浏览器向web服务器发出请求的时，一般会带上Referer请求头，告诉服务器用户从哪个页面连接过来的
2. js中通过`document.referrer`获取referrer
3. 如在`www.bank.com`上的一个按钮，点击转账功能，Referer肯定执行`www.bank.com`的某个地址，对于CSRF攻击，黑客需要在自己网站构造请求，referer值肯定与`www.bank.com`不同
4. 但referer值由浏览器提供，不能保证浏览器没有安全漏洞，而且这种方式是将安全性都依赖于第三方（即浏览器）来保障
5. 还有就是由于referer值会记录用户的访问来源，有些组织担心内网信息被暴露，设置浏览器发送请求时不提供referer字段

## Anti CSRF Token

### 基本方式

1. 服务端在收到路由请求时，生成一个随机数token，在渲染请求页面时把随机数埋入页面（一般埋入 form 表单内，<input type="hidden" name="csrf_token" value="xxxx">）
2. 将token保存在session中
3. 当用户发送 GET 或者 POST 请求时带上csrf_token参数
4. 服务器将用户发来的token与session中的token进行对比。
5. 由于黑客无法获取随机的token，故可以防止黑客进行csrf攻击

### 基本方式的缺点

1. 如果请求很多每个请求都加上token很麻烦，很容易遗漏
2. 可以页面每次加载时，使用js遍历dom，给每个a和form增加token
3. 但对于js动态生成的js，还需要程序猿手动添加
4. 但上面的方法不能保证token本身安全，如一个支持用户发表信息的网站，黑客可以发布自己的网站，原网站的token就被附带（这个问题可以结合Referer来避免，不是自己站的不增加token，但使用Referer就有上述Referer问题）

### HTTP自定义属性

1. 利用ajax，将token放于HTTP自定义属性中
2. 但这种方式只能用于ajax局部刷新

### 结论

1. 目前还没有完美的解决方案



# HTTPS降级攻击

1. 唯一解决问题的方法是禁用 SSL 3.0 加密协议

# 警惕iframe带来的风险

## 概述

1. 前端页面需要用到第三方提供的页面组件，通常会以iframe的方式引入。
2. 如果iframe中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件等等，这问题可就大了 

## 如何防御

1. 在HTML5中，iframe有了一个叫做sandbox的安全属性 
2. 可以对iframe进行细粒度的操作，比如不准提交表单、不准弹窗、不准执行脚本等等 





# SQL注入

1. 之所以会发生SQL注入，主要因为代码中存在拼接SQL语句的情况 



# Node安全最佳实践

1. https://mp.weixin.qq.com/s/2CBGgtja04NnOerpKfk0Ug
   - node官方文档security的中文翻译
